<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libwebsockets: lib/libwebsockets.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="libwebsockets.org-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libwebsockets
   </div>
   <div id="projectbrief">Lightweight C library for HTML5 websockets</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">libwebsockets.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdarg.h&gt;</code><br />
<code>#include &quot;lws_config.h&quot;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;poll.h&gt;</code><br />
<code>#include &lt;netdb.h&gt;</code><br />
<code>#include &lt;sys/time.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div>
<p><a href="libwebsockets_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__pollargs.html">lws_pollargs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__plat__file__ops.html">lws_plat_file_ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__tokens.html">lws_tokens</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__token__limits.html">lws_token_limits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__protocols.html">lws_protocols</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__session__info.html">lws_session_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__process__html__args.html">lws_process_html_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__process__html__state.html">lws_process_html_state</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlwsgw__hash__bin.html">lwsgw_hash_bin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlwsgw__hash.html">lwsgw_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__gs__event__args.html">lws_gs_event_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__ext__options.html">lws_ext_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__ext__option__arg.html">lws_ext_option_arg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__extension.html">lws_extension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__protocol__vhost__options.html">lws_protocol_vhost_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__http__mount.html">lws_http_mount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlws__client__connect__info.html">lws_client_connect_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8b8b394f480f5ce1fcca313fc0a76aea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b8b394f480f5ce1fcca313fc0a76aea"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_POSIX</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a8b8b394f480f5ce1fcca313fc0a76aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9f6194a06f30387016bf93b436a346"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b9f6194a06f30387016bf93b436a346"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_INLINE</b>&#160;&#160;&#160;inline</td></tr>
<tr class="separator:a6b9f6194a06f30387016bf93b436a346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740612cfea56a42d05b614fbdc29ede8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a740612cfea56a42d05b614fbdc29ede8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_O_RDONLY</b>&#160;&#160;&#160;O_RDONLY</td></tr>
<tr class="separator:a740612cfea56a42d05b614fbdc29ede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f27bbb90294fe13cd667b08628247b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f27bbb90294fe13cd667b08628247b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_INVALID_FILE</b>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:a32f27bbb90294fe13cd667b08628247b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40ab5bcb8dadc6a09db5fb48bc233ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae40ab5bcb8dadc6a09db5fb48bc233ef"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_VISIBLE</b></td></tr>
<tr class="separator:ae40ab5bcb8dadc6a09db5fb48bc233ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1444c041f0b4ddd07c3bcb926c5f62f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1444c041f0b4ddd07c3bcb926c5f62f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_WARN_UNUSED_RESULT</b></td></tr>
<tr class="separator:ae1444c041f0b4ddd07c3bcb926c5f62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fd73391d19e0437abe2f168cd7a182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49fd73391d19e0437abe2f168cd7a182"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_WARN_DEPRECATED</b></td></tr>
<tr class="separator:a49fd73391d19e0437abe2f168cd7a182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5e8e22f741c14185fc5fd8f829b3dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a5e8e22f741c14185fc5fd8f829b3dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_EXTERN</b>&#160;&#160;&#160;extern</td></tr>
<tr class="separator:a9a5e8e22f741c14185fc5fd8f829b3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c27d47e0df70f1c2e091bc18caf8e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c27d47e0df70f1c2e091bc18caf8e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CONTEXT_PORT_NO_LISTEN</b>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:af0c27d47e0df70f1c2e091bc18caf8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b3c56c638569eb93919c52a1d5dfaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86b3c56c638569eb93919c52a1d5dfaf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_notice</b>(...)&#160;&#160;&#160;_lws_log(LLL_NOTICE, __VA_ARGS__)</td></tr>
<tr class="separator:a86b3c56c638569eb93919c52a1d5dfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcd293826c0a91d6e7ac3c54db72885"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bcd293826c0a91d6e7ac3c54db72885"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_warn</b>(...)&#160;&#160;&#160;_lws_log(LLL_WARN, __VA_ARGS__)</td></tr>
<tr class="separator:a1bcd293826c0a91d6e7ac3c54db72885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44c15d00076052a398244035a7dbb56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad44c15d00076052a398244035a7dbb56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_err</b>(...)&#160;&#160;&#160;_lws_log(LLL_ERR, __VA_ARGS__)</td></tr>
<tr class="separator:ad44c15d00076052a398244035a7dbb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13957a4d9fb47c070b9320303c32502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af13957a4d9fb47c070b9320303c32502"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_info</b>(...)&#160;&#160;&#160;{}</td></tr>
<tr class="separator:af13957a4d9fb47c070b9320303c32502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a1a3d4d96b146a0ac45faab0028ade"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a1a3d4d96b146a0ac45faab0028ade"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_debug</b>(...)&#160;&#160;&#160;{}</td></tr>
<tr class="separator:a74a1a3d4d96b146a0ac45faab0028ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee051a14945bec746ed3b527f384dc72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee051a14945bec746ed3b527f384dc72"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_parser</b>(...)&#160;&#160;&#160;{}</td></tr>
<tr class="separator:aee051a14945bec746ed3b527f384dc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab72aa186eff075fb3d229cb99a35434"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab72aa186eff075fb3d229cb99a35434"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_header</b>(...)&#160;&#160;&#160;{}</td></tr>
<tr class="separator:aab72aa186eff075fb3d229cb99a35434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0877b452d80bc154793ad81bfce742"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e0877b452d80bc154793ad81bfce742"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_ext</b>(...)&#160;&#160;&#160;{}</td></tr>
<tr class="separator:a8e0877b452d80bc154793ad81bfce742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181ea1ed9ba604e493ce092850d9da90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a181ea1ed9ba604e493ce092850d9da90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_client</b>(...)&#160;&#160;&#160;{}</td></tr>
<tr class="separator:a181ea1ed9ba604e493ce092850d9da90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5842ee4ec5f763d057869e083ff1cb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5842ee4ec5f763d057869e083ff1cb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_latency</b>(...)&#160;&#160;&#160;{}</td></tr>
<tr class="separator:ab5842ee4ec5f763d057869e083ff1cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a07bbef36a60911dd379b2f46a8ea2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a07bbef36a60911dd379b2f46a8ea2d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_hexdump</b>(a,  b)</td></tr>
<tr class="separator:a5a07bbef36a60911dd379b2f46a8ea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352ae6384329728d70a7836d65e20718"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a352ae6384329728d70a7836d65e20718"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_container_of</b>(P,  T,  M)&#160;&#160;&#160;((T *)((char *)(P) - offsetof(T, M)))</td></tr>
<tr class="separator:a352ae6384329728d70a7836d65e20718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6242a25f9d996f0cc4f4cdb911218b75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ARRAY_SIZE</b>(x)&#160;&#160;&#160;(sizeof(x) / sizeof(x[0]))</td></tr>
<tr class="separator:a6242a25f9d996f0cc4f4cdb911218b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829453cc63428e7d136954b483e34a26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a829453cc63428e7d136954b483e34a26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_FEATURE_SERVE_HTTP_FILE_HAS_OTHER_HEADERS_ARG</b></td></tr>
<tr class="separator:a829453cc63428e7d136954b483e34a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7a9211adaaa8c4fec9e2373f0792d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad7a9211adaaa8c4fec9e2373f0792d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_FEATURE_PROTOCOLS_HAS_ID_FIELD</b></td></tr>
<tr class="separator:aad7a9211adaaa8c4fec9e2373f0792d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7d8de7381f91ae842b15939356c7f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad7d8de7381f91ae842b15939356c7f3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_FEATURE_PROTOCOLS_HAS_PEER_WRITE_ALLOWANCE</b></td></tr>
<tr class="separator:aad7d8de7381f91ae842b15939356c7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42eba60a5dfb5d1e9379101dfe18077"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af42eba60a5dfb5d1e9379101dfe18077"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_FEATURE_SERVE_HTTP_FILE_HAS_OTHER_HEADERS_LEN</b></td></tr>
<tr class="separator:af42eba60a5dfb5d1e9379101dfe18077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d53cc571c4f3c47e0170c8b6efd58bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d53cc571c4f3c47e0170c8b6efd58bb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_FEATURE_FOPS</b></td></tr>
<tr class="separator:a7d53cc571c4f3c47e0170c8b6efd58bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6bad7f34d6b9a55e92353362372b9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea6bad7f34d6b9a55e92353362372b9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_check_opt</b>(c,  f)&#160;&#160;&#160;(((c) &amp; (f)) == (f))</td></tr>
<tr class="separator:aea6bad7f34d6b9a55e92353362372b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fc7a2d446950856b06273940fcd81c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1fc7a2d446950856b06273940fcd81c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_sockfd_valid</b>(sfd)&#160;&#160;&#160;(sfd &gt;= 0)</td></tr>
<tr class="separator:aa1fc7a2d446950856b06273940fcd81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a62607020e6e31d5e6d2c8cc2aeb10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40a62607020e6e31d5e6d2c8cc2aeb10"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_pollfd</b>&#160;&#160;&#160;pollfd</td></tr>
<tr class="separator:a40a62607020e6e31d5e6d2c8cc2aeb10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e0d172d9bc26a18f80774f3950b952"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22e0d172d9bc26a18f80774f3950b952"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWSGS_EMAIL_CONTENT_SIZE</b>&#160;&#160;&#160;16384</td></tr>
<tr class="separator:a22e0d172d9bc26a18f80774f3950b952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5743ab25b8c247967b8aec92b8957515"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5743ab25b8c247967b8aec92b8957515"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_SIZEOFPTR</b>&#160;&#160;&#160;(sizeof (void *))</td></tr>
<tr class="separator:a5743ab25b8c247967b8aec92b8957515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabbb92bc177061361d851f856adc077"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adabbb92bc177061361d851f856adc077"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>u_int64_t</b>&#160;&#160;&#160;unsigned long long</td></tr>
<tr class="separator:adabbb92bc177061361d851f856adc077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf62a0c9131cb729d33d12635ba705df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf62a0c9131cb729d33d12635ba705df"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_LWS_PAD_SIZE</b>&#160;&#160;&#160;LWS_SIZEOFPTR   /* Size of a pointer on the target arch */</td></tr>
<tr class="separator:adf62a0c9131cb729d33d12635ba705df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75ea60043f76634f5b05a7eeb633394"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>_LWS_PAD</b>(n)</td></tr>
<tr class="separator:ab75ea60043f76634f5b05a7eeb633394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d23d62835d86e1b95d8ffdeee72268"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1d23d62835d86e1b95d8ffdeee72268"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_PRE</b>&#160;&#160;&#160;_LWS_PAD(4 + 10)</td></tr>
<tr class="separator:ae1d23d62835d86e1b95d8ffdeee72268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085d18f12bd9dfaf86862db6d4923179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a085d18f12bd9dfaf86862db6d4923179"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_SEND_BUFFER_PRE_PADDING</b>&#160;&#160;&#160;LWS_PRE</td></tr>
<tr class="separator:a085d18f12bd9dfaf86862db6d4923179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11d0accbfe6cab32df54927e4c676bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab11d0accbfe6cab32df54927e4c676bf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LWS_SEND_BUFFER_POST_PADDING</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab11d0accbfe6cab32df54927e4c676bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163368ee0669418c93c16288e09a719b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a163368ee0669418c93c16288e09a719b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>lws_write_http</b>(wsi,  buf,  len)&#160;&#160;&#160;<a class="el" href="libwebsockets_8h.html#afd5fdd285a0e25ba7e3e1051deec1001">lws_write</a>(wsi, (unsigned char *)(buf), len, <a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193dabb6705e1d1327cdda5025be28f07712e">LWS_WRITE_HTTP</a>)</td></tr>
<tr class="separator:a163368ee0669418c93c16288e09a719b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adedbc79528b71a5c7f27cde87100c9aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adedbc79528b71a5c7f27cde87100c9aa"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_sockfd_type</b></td></tr>
<tr class="separator:adedbc79528b71a5c7f27cde87100c9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff42d53861afdc1a6edfb999ba688ecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff42d53861afdc1a6edfb999ba688ecb"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_filefd_type</b></td></tr>
<tr class="separator:aff42d53861afdc1a6edfb999ba688ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function</a>(struct lws *wsi, enum <a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:ad4fcb82e68d60ffacca61a3f783a0a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7169b2cd346b34fa33d0250db2afd0"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aae7169b2cd346b34fa33d0250db2afd0">lws_extension_callback_function</a>(struct lws_context *context, const struct <a class="el" href="structlws__extension.html">lws_extension</a> *ext, struct lws *wsi, enum lws_extension_callback_reasons reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:aae7169b2cd346b34fa33d0250db2afd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669d3d7ce2d5f193473f649a89b3e7ac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a669d3d7ce2d5f193473f649a89b3e7ac"></a>
typedef const char *(*&#160;</td><td class="memItemRight" valign="bottom"><b>lws_process_html_state_cb</b>) (void *data, int index)</td></tr>
<tr class="separator:a669d3d7ce2d5f193473f649a89b3e7ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a70527c0861c2ffa3d29333a6aa7f8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a70527c0861c2ffa3d29333a6aa7f8e"></a>
typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><b>lws_spa_fileupload_cb</b>) (void *data, const char *name, const char *filename, char *buf, int len, enum lws_spa_fileupload_states state)</td></tr>
<tr class="separator:a5a70527c0861c2ffa3d29333a6aa7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a14542b84d2c76efa7814124bb10f9c5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14542b84d2c76efa7814124bb10f9c5f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lws_log_levels</b> { <br />
&#160;&#160;<b>LLL_ERR</b> = 1 &lt;&lt; 0, 
<b>LLL_WARN</b> = 1 &lt;&lt; 1, 
<b>LLL_NOTICE</b> = 1 &lt;&lt; 2, 
<b>LLL_INFO</b> = 1 &lt;&lt; 3, 
<br />
&#160;&#160;<b>LLL_DEBUG</b> = 1 &lt;&lt; 4, 
<b>LLL_PARSER</b> = 1 &lt;&lt; 5, 
<b>LLL_HEADER</b> = 1 &lt;&lt; 6, 
<b>LLL_EXT</b> = 1 &lt;&lt; 7, 
<br />
&#160;&#160;<b>LLL_CLIENT</b> = 1 &lt;&lt; 8, 
<b>LLL_LATENCY</b> = 1 &lt;&lt; 9, 
<b>LLL_COUNT</b> = 10
<br />
 }</td></tr>
<tr class="separator:a14542b84d2c76efa7814124bb10f9c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c2d763f78cc248df3b9f8645dbd2a5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5">lws_context_options</a> { <br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a274ed462a1a9239eb6ddf9007f5b7092">LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT</a>, 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a6582c985ee0ceaadc1d277030eae2d7c">LWS_SERVER_OPTION_SKIP_SERVER_CANONICAL_NAME</a> = (1 &lt;&lt; 2), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a1cc4562d05cba52a6dfa0697a65ade0d">LWS_SERVER_OPTION_ALLOW_NON_SSL_ON_SSL_PORT</a>, 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a273d9975675130de0c6dc937dde7c8a6">LWS_SERVER_OPTION_LIBEV</a> = (1 &lt;&lt; 4), 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a34ab36e68c0d593b6f19b8d5ef1240a9">LWS_SERVER_OPTION_DISABLE_IPV6</a> = (1 &lt;&lt; 5), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a4933347a821e73c3f1e13fb6bfc7ad93">LWS_SERVER_OPTION_DISABLE_OS_CA_CERTS</a> = (1 &lt;&lt; 6), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5ac56a8a6590e74a8016d0fae09fb404fc">LWS_SERVER_OPTION_PEER_CERT_NOT_REQUIRED</a> = (1 &lt;&lt; 7), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5aa0158b4e85420811e6b0f1378c6ded0f">LWS_SERVER_OPTION_VALIDATE_UTF8</a> = (1 &lt;&lt; 8), 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a1b2f8bde0f62adc7ebe81b2043f34c0c">LWS_SERVER_OPTION_SSL_ECDH</a>, 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5aff121db04a10cf8b2c5df9d4f2b89f1e">LWS_SERVER_OPTION_LIBUV</a> = (1 &lt;&lt; 10), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a4832187186c4d130c68051214cd42ada">LWS_SERVER_OPTION_REDIRECT_HTTP_TO_HTTPS</a>, 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a7fed6a527c8d5e0acac1b4179644583a">LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT</a> = (1 &lt;&lt; 12), 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5accc9d0d11d1124a21659586164b0962e">LWS_SERVER_OPTION_EXPLICIT_VHOSTS</a> = (1 &lt;&lt; 13), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5a9637e9001d8c8b2521086bcafbd8a941">LWS_SERVER_OPTION_UNIX_SOCK</a> = (1 &lt;&lt; 14), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5ac962efd35abf6c402f9fb14aa14f5016">LWS_SERVER_OPTION_STS</a> = (1 &lt;&lt; 15), 
<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5af62887536e25e053e68741006dba46d8">LWS_SERVER_OPTION_IPV6_V6ONLY_MODIFY</a> = (1 &lt;&lt; 16), 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5aca5d42820b65eac5618ec3f0bd8a1160">LWS_SERVER_OPTION_IPV6_V6ONLY_VALUE</a> = (1 &lt;&lt; 17)
<br />
 }</td></tr>
<tr class="separator:a41c2d763f78cc248df3b9f8645dbd2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62860e19975ba4c4af401c3cdb6abf7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> { <br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439">LWS_CALLBACK_ESTABLISHED</a> = 0, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8">LWS_CALLBACK_CLIENT_CONNECTION_ERROR</a> = 1, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2">LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH</a> = 2, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604">LWS_CALLBACK_CLIENT_ESTABLISHED</a> = 3, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8">LWS_CALLBACK_CLOSED</a> = 4, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba">LWS_CALLBACK_CLOSED_HTTP</a> = 5, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c">LWS_CALLBACK_RECEIVE</a> = 6, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738">LWS_CALLBACK_RECEIVE_PONG</a> = 7, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1">LWS_CALLBACK_CLIENT_RECEIVE</a> = 8, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9">LWS_CALLBACK_CLIENT_RECEIVE_PONG</a> = 9, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514">LWS_CALLBACK_CLIENT_WRITEABLE</a> = 10, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc">LWS_CALLBACK_SERVER_WRITEABLE</a> = 11, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e">LWS_CALLBACK_HTTP</a> = 12, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae">LWS_CALLBACK_HTTP_BODY</a> = 13, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804">LWS_CALLBACK_HTTP_BODY_COMPLETION</a> = 14, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587">LWS_CALLBACK_HTTP_FILE_COMPLETION</a> = 15, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09">LWS_CALLBACK_HTTP_WRITEABLE</a> = 16, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6">LWS_CALLBACK_FILTER_NETWORK_CONNECTION</a> = 17, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c">LWS_CALLBACK_FILTER_HTTP_CONNECTION</a> = 18, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3">LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED</a> = 19, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d">LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION</a> = 20, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS</a> = 21, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493">LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS</a> = 22, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac">LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION</a> = 23, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f">LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER</a> = 24, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e">LWS_CALLBACK_CONFIRM_EXTENSION_OKAY</a> = 25, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46">LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED</a> = 26, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49">LWS_CALLBACK_PROTOCOL_INIT</a> = 27, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa">LWS_CALLBACK_PROTOCOL_DESTROY</a> = 28, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01">LWS_CALLBACK_WSI_CREATE</a> = 29, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e">LWS_CALLBACK_WSI_DESTROY</a> = 30, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34">LWS_CALLBACK_GET_THREAD_ID</a> = 31, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412">LWS_CALLBACK_ADD_POLL_FD</a> = 32, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768">LWS_CALLBACK_DEL_POLL_FD</a> = 33, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e">LWS_CALLBACK_CHANGE_MODE_POLL_FD</a> = 34, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428">LWS_CALLBACK_LOCK_POLL</a> = 35, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79">LWS_CALLBACK_UNLOCK_POLL</a> = 36, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b">LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY</a> = 37, 
<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51">LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</a> = 38, 
<b>LWS_CALLBACK_WS_EXT_DEFAULTS</b> = 39, 
<br />
&#160;&#160;<b>LWS_CALLBACK_CGI</b> = 40, 
<b>LWS_CALLBACK_CGI_TERMINATED</b> = 41, 
<b>LWS_CALLBACK_CGI_STDIN_DATA</b> = 42, 
<b>LWS_CALLBACK_CGI_STDIN_COMPLETED</b> = 43, 
<br />
&#160;&#160;<b>LWS_CALLBACK_ESTABLISHED_CLIENT_HTTP</b> = 44, 
<b>LWS_CALLBACK_CLOSED_CLIENT_HTTP</b> = 45, 
<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP</b> = 46, 
<b>LWS_CALLBACK_COMPLETED_CLIENT_HTTP</b> = 47, 
<br />
&#160;&#160;<b>LWS_CALLBACK_RECEIVE_CLIENT_HTTP_READ</b> = 48, 
<b>LWS_CALLBACK_HTTP_BIND_PROTOCOL</b> = 49, 
<b>LWS_CALLBACK_HTTP_DROP_PROTOCOL</b> = 50, 
<b>LWS_CALLBACK_CHECK_ACCESS_RIGHTS</b> = 51, 
<br />
&#160;&#160;<b>LWS_CALLBACK_PROCESS_HTML</b> = 52, 
<b>LWS_CALLBACK_ADD_HEADERS</b> = 53, 
<b>LWS_CALLBACK_SESSION_INFO</b> = 54, 
<b>LWS_CALLBACK_GS_EVENT</b> = 55, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a">LWS_CALLBACK_USER</a> = 1000
<br />
 }</td></tr>
<tr class="separator:ad62860e19975ba4c4af401c3cdb6abf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9993815eee72c6070300a0ae2f022d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9993815eee72c6070300a0ae2f022d7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lws_extension_callback_reasons</b> { <br />
&#160;&#160;<b>LWS_EXT_CB_SERVER_CONTEXT_CONSTRUCT</b> = 0, 
<b>LWS_EXT_CB_CLIENT_CONTEXT_CONSTRUCT</b> = 1, 
<b>LWS_EXT_CB_SERVER_CONTEXT_DESTRUCT</b> = 2, 
<b>LWS_EXT_CB_CLIENT_CONTEXT_DESTRUCT</b> = 3, 
<br />
&#160;&#160;<b>LWS_EXT_CB_CONSTRUCT</b> = 4, 
<b>LWS_EXT_CB_CLIENT_CONSTRUCT</b> = 5, 
<b>LWS_EXT_CB_CHECK_OK_TO_REALLY_CLOSE</b> = 6, 
<b>LWS_EXT_CB_CHECK_OK_TO_PROPOSE_EXTENSION</b> = 7, 
<br />
&#160;&#160;<b>LWS_EXT_CB_DESTROY</b> = 8, 
<b>LWS_EXT_CB_DESTROY_ANY_WSI_CLOSING</b> = 9, 
<b>LWS_EXT_CB_ANY_WSI_ESTABLISHED</b> = 10, 
<b>LWS_EXT_CB_PACKET_RX_PREPARSE</b> = 11, 
<br />
&#160;&#160;<b>LWS_EXT_CB_PACKET_TX_PRESEND</b> = 12, 
<b>LWS_EXT_CB_PACKET_TX_DO_SEND</b> = 13, 
<b>LWS_EXT_CB_HANDSHAKE_REPLY_TX</b> = 14, 
<b>LWS_EXT_CB_FLUSH_PENDING_TX</b> = 15, 
<br />
&#160;&#160;<b>LWS_EXT_CB_EXTENDED_PAYLOAD_RX</b> = 16, 
<b>LWS_EXT_CB_CAN_PROXY_CLIENT_CONNECTION</b> = 17, 
<b>LWS_EXT_CB_1HZ</b> = 18, 
<b>LWS_EXT_CB_REQUEST_ON_WRITEABLE</b> = 19, 
<br />
&#160;&#160;<b>LWS_EXT_CB_IS_WRITEABLE</b> = 20, 
<b>LWS_EXT_CB_PAYLOAD_TX</b> = 21, 
<b>LWS_EXT_CB_PAYLOAD_RX</b> = 22, 
<b>LWS_EXT_CB_OPTION_DEFAULT</b> = 23, 
<br />
&#160;&#160;<b>LWS_EXT_CB_OPTION_SET</b> = 24, 
<b>LWS_EXT_CB_OPTION_CONFIRM</b> = 25, 
<b>LWS_EXT_CB_NAMED_OPTION_SET</b> = 26
<br />
 }</td></tr>
<tr class="separator:ae9993815eee72c6070300a0ae2f022d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b099cf8c1c7e38ad78501f270e193d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193d">lws_write_protocol</a> { <br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193da80e8f169fda236c56bfb795ed62903db">LWS_WRITE_TEXT</a> = 0, 
<a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193daf6486c0dba50c44198100717721d9ab2">LWS_WRITE_BINARY</a> = 1, 
<a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193da10047eb05b5e1c298151dc47a5b44826">LWS_WRITE_CONTINUATION</a> = 2, 
<a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193dabb6705e1d1327cdda5025be28f07712e">LWS_WRITE_HTTP</a> = 3, 
<br />
&#160;&#160;<b>LWS_WRITE_PING</b> = 5, 
<b>LWS_WRITE_PONG</b> = 6, 
<b>LWS_WRITE_HTTP_FINAL</b> = 7, 
<a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193dafe5a38e940ce56708ac814627e9c0917">LWS_WRITE_HTTP_HEADERS</a> = 8, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193da115440f272a5d55518adfc8099acfee3">LWS_WRITE_NO_FIN</a> = 0x40, 
<a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193da220d8e8652d9b97fb66e476e2a60ffce">LWS_WRITE_CLIENT_IGNORE_XOR_MASK</a> = 0x80
<br />
 }</td></tr>
<tr class="separator:a98b099cf8c1c7e38ad78501f270e193d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e747906f9d76532ec118d6ef418b82e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e747906f9d76532ec118d6ef418b82e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lws_token_indexes</b> { <br />
&#160;&#160;<b>WSI_TOKEN_GET_URI</b> = 0, 
<b>WSI_TOKEN_POST_URI</b> = 1, 
<b>WSI_TOKEN_OPTIONS_URI</b> = 2, 
<b>WSI_TOKEN_HOST</b> = 3, 
<br />
&#160;&#160;<b>WSI_TOKEN_CONNECTION</b> = 4, 
<b>WSI_TOKEN_UPGRADE</b> = 5, 
<b>WSI_TOKEN_ORIGIN</b> = 6, 
<b>WSI_TOKEN_DRAFT</b> = 7, 
<br />
&#160;&#160;<b>WSI_TOKEN_CHALLENGE</b> = 8, 
<b>WSI_TOKEN_EXTENSIONS</b> = 9, 
<b>WSI_TOKEN_KEY1</b> = 10, 
<b>WSI_TOKEN_KEY2</b> = 11, 
<br />
&#160;&#160;<b>WSI_TOKEN_PROTOCOL</b> = 12, 
<b>WSI_TOKEN_ACCEPT</b> = 13, 
<b>WSI_TOKEN_NONCE</b> = 14, 
<b>WSI_TOKEN_HTTP</b> = 15, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP2_SETTINGS</b> = 16, 
<b>WSI_TOKEN_HTTP_ACCEPT</b> = 17, 
<b>WSI_TOKEN_HTTP_AC_REQUEST_HEADERS</b> = 18, 
<b>WSI_TOKEN_HTTP_IF_MODIFIED_SINCE</b> = 19, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_IF_NONE_MATCH</b> = 20, 
<b>WSI_TOKEN_HTTP_ACCEPT_ENCODING</b> = 21, 
<b>WSI_TOKEN_HTTP_ACCEPT_LANGUAGE</b> = 22, 
<b>WSI_TOKEN_HTTP_PRAGMA</b> = 23, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_CACHE_CONTROL</b> = 24, 
<b>WSI_TOKEN_HTTP_AUTHORIZATION</b> = 25, 
<b>WSI_TOKEN_HTTP_COOKIE</b> = 26, 
<b>WSI_TOKEN_HTTP_CONTENT_LENGTH</b> = 27, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_CONTENT_TYPE</b> = 28, 
<b>WSI_TOKEN_HTTP_DATE</b> = 29, 
<b>WSI_TOKEN_HTTP_RANGE</b> = 30, 
<b>WSI_TOKEN_HTTP_REFERER</b> = 31, 
<br />
&#160;&#160;<b>WSI_TOKEN_KEY</b> = 32, 
<b>WSI_TOKEN_VERSION</b> = 33, 
<b>WSI_TOKEN_SWORIGIN</b> = 34, 
<b>WSI_TOKEN_HTTP_COLON_AUTHORITY</b> = 35, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_COLON_METHOD</b> = 36, 
<b>WSI_TOKEN_HTTP_COLON_PATH</b> = 37, 
<b>WSI_TOKEN_HTTP_COLON_SCHEME</b> = 38, 
<b>WSI_TOKEN_HTTP_COLON_STATUS</b> = 39, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_ACCEPT_CHARSET</b> = 40, 
<b>WSI_TOKEN_HTTP_ACCEPT_RANGES</b> = 41, 
<b>WSI_TOKEN_HTTP_ACCESS_CONTROL_ALLOW_ORIGIN</b> = 42, 
<b>WSI_TOKEN_HTTP_AGE</b> = 43, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_ALLOW</b> = 44, 
<b>WSI_TOKEN_HTTP_CONTENT_DISPOSITION</b> = 45, 
<b>WSI_TOKEN_HTTP_CONTENT_ENCODING</b> = 46, 
<b>WSI_TOKEN_HTTP_CONTENT_LANGUAGE</b> = 47, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_CONTENT_LOCATION</b> = 48, 
<b>WSI_TOKEN_HTTP_CONTENT_RANGE</b> = 49, 
<b>WSI_TOKEN_HTTP_ETAG</b> = 50, 
<b>WSI_TOKEN_HTTP_EXPECT</b> = 51, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_EXPIRES</b> = 52, 
<b>WSI_TOKEN_HTTP_FROM</b> = 53, 
<b>WSI_TOKEN_HTTP_IF_MATCH</b> = 54, 
<b>WSI_TOKEN_HTTP_IF_RANGE</b> = 55, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_IF_UNMODIFIED_SINCE</b> = 56, 
<b>WSI_TOKEN_HTTP_LAST_MODIFIED</b> = 57, 
<b>WSI_TOKEN_HTTP_LINK</b> = 58, 
<b>WSI_TOKEN_HTTP_LOCATION</b> = 59, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_MAX_FORWARDS</b> = 60, 
<b>WSI_TOKEN_HTTP_PROXY_AUTHENTICATE</b> = 61, 
<b>WSI_TOKEN_HTTP_PROXY_AUTHORIZATION</b> = 62, 
<b>WSI_TOKEN_HTTP_REFRESH</b> = 63, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_RETRY_AFTER</b> = 64, 
<b>WSI_TOKEN_HTTP_SERVER</b> = 65, 
<b>WSI_TOKEN_HTTP_SET_COOKIE</b> = 66, 
<b>WSI_TOKEN_HTTP_STRICT_TRANSPORT_SECURITY</b> = 67, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_TRANSFER_ENCODING</b> = 68, 
<b>WSI_TOKEN_HTTP_USER_AGENT</b> = 69, 
<b>WSI_TOKEN_HTTP_VARY</b> = 70, 
<b>WSI_TOKEN_HTTP_VIA</b> = 71, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_WWW_AUTHENTICATE</b> = 72, 
<b>WSI_TOKEN_PATCH_URI</b> = 73, 
<b>WSI_TOKEN_PUT_URI</b> = 74, 
<b>WSI_TOKEN_DELETE_URI</b> = 75, 
<br />
&#160;&#160;<b>WSI_TOKEN_HTTP_URI_ARGS</b> = 76, 
<b>WSI_TOKEN_PROXY</b> = 77, 
<b>WSI_TOKEN_HTTP_X_REAL_IP</b> = 78, 
<b>WSI_TOKEN_HTTP1_0</b> = 79, 
<br />
&#160;&#160;<b>_WSI_TOKEN_CLIENT_SENT_PROTOCOLS</b>, 
<b>_WSI_TOKEN_CLIENT_PEER_ADDRESS</b>, 
<b>_WSI_TOKEN_CLIENT_URI</b>, 
<b>_WSI_TOKEN_CLIENT_HOST</b>, 
<br />
&#160;&#160;<b>_WSI_TOKEN_CLIENT_ORIGIN</b>, 
<b>_WSI_TOKEN_CLIENT_METHOD</b>, 
<b>WSI_TOKEN_COUNT</b>, 
<b>WSI_TOKEN_NAME_PART</b>, 
<br />
&#160;&#160;<b>WSI_TOKEN_SKIPPING</b>, 
<b>WSI_TOKEN_SKIPPING_SAW_CR</b>, 
<b>WSI_PARSING_COMPLETE</b>, 
<b>WSI_INIT_TOKEN_MUXURL</b>
<br />
 }</td></tr>
<tr class="separator:a6e747906f9d76532ec118d6ef418b82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae399c571df32ba532c0ca67da9284985"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985">lws_close_status</a> { <br />
&#160;&#160;<b>LWS_CLOSE_STATUS_NOSTATUS</b> = 0, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a3ffa38d5081b85fb739e02a747ccf2c4">LWS_CLOSE_STATUS_NORMAL</a> = 1000, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a9737a68759e739856b150ff9dfa30218">LWS_CLOSE_STATUS_GOINGAWAY</a> = 1001, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a1bb501d212fa4d57053db681b1dfab98">LWS_CLOSE_STATUS_PROTOCOL_ERR</a> = 1002, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a462c99b05459df700919cfd3f53c8276">LWS_CLOSE_STATUS_UNACCEPTABLE_OPCODE</a> = 1003, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985af90cb98d983ad3d4c79df9b6f3d4a4d2">LWS_CLOSE_STATUS_RESERVED</a> = 1004, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a4b8a3b7ce6f731e5248e4b0fb64a5044">LWS_CLOSE_STATUS_NO_STATUS</a> = 1005, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a68b3d34bebd88547dcfa5cadba0acd6c">LWS_CLOSE_STATUS_ABNORMAL_CLOSE</a> = 1006, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a7aef2da0062da606eeb35aaca5cf9050">LWS_CLOSE_STATUS_INVALID_PAYLOAD</a> = 1007, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985ad09e68295eabdddcba4e332fbea70ae5">LWS_CLOSE_STATUS_POLICY_VIOLATION</a> = 1008, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985a2e1f0113494a58e762eed3d22e7080d8">LWS_CLOSE_STATUS_MESSAGE_TOO_LARGE</a> = 1009, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985ac6a161822783ee873be1c66f48d14e0e">LWS_CLOSE_STATUS_EXTENSION_REQUIRED</a> = 1010, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985ad0869604d79e13700ae5d196a431b350">LWS_CLOSE_STATUS_UNEXPECTED_CONDITION</a> = 1011, 
<a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985ad2b477a91c8445bf34ecd43977f9b390">LWS_CLOSE_STATUS_TLS_FAILURE</a> = 1015, 
<b>LWS_CLOSE_STATUS_NOSTATUS_CONTEXT_DESTROY</b> = 9999
<br />
 }</td></tr>
<tr class="separator:ae399c571df32ba532c0ca67da9284985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3b93f68c8bdd857ad32913628dfa8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc3b93f68c8bdd857ad32913628dfa8d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>http_status</b> { <br />
&#160;&#160;<b>HTTP_STATUS_OK</b> = 200, 
<b>HTTP_STATUS_NO_CONTENT</b> = 204, 
<b>HTTP_STATUS_MOVED_PERMANENTLY</b> = 301, 
<b>HTTP_STATUS_FOUND</b> = 302, 
<br />
&#160;&#160;<b>HTTP_STATUS_SEE_OTHER</b> = 303, 
<b>HTTP_STATUS_BAD_REQUEST</b> = 400, 
<b>HTTP_STATUS_UNAUTHORIZED</b>, 
<b>HTTP_STATUS_PAYMENT_REQUIRED</b>, 
<br />
&#160;&#160;<b>HTTP_STATUS_FORBIDDEN</b>, 
<b>HTTP_STATUS_NOT_FOUND</b>, 
<b>HTTP_STATUS_METHOD_NOT_ALLOWED</b>, 
<b>HTTP_STATUS_NOT_ACCEPTABLE</b>, 
<br />
&#160;&#160;<b>HTTP_STATUS_PROXY_AUTH_REQUIRED</b>, 
<b>HTTP_STATUS_REQUEST_TIMEOUT</b>, 
<b>HTTP_STATUS_CONFLICT</b>, 
<b>HTTP_STATUS_GONE</b>, 
<br />
&#160;&#160;<b>HTTP_STATUS_LENGTH_REQUIRED</b>, 
<b>HTTP_STATUS_PRECONDITION_FAILED</b>, 
<b>HTTP_STATUS_REQ_ENTITY_TOO_LARGE</b>, 
<b>HTTP_STATUS_REQ_URI_TOO_LONG</b>, 
<br />
&#160;&#160;<b>HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE</b>, 
<b>HTTP_STATUS_REQ_RANGE_NOT_SATISFIABLE</b>, 
<b>HTTP_STATUS_EXPECTATION_FAILED</b>, 
<b>HTTP_STATUS_INTERNAL_SERVER_ERROR</b> = 500, 
<br />
&#160;&#160;<b>HTTP_STATUS_NOT_IMPLEMENTED</b>, 
<b>HTTP_STATUS_BAD_GATEWAY</b>, 
<b>HTTP_STATUS_SERVICE_UNAVAILABLE</b>, 
<b>HTTP_STATUS_GATEWAY_TIMEOUT</b>, 
<br />
&#160;&#160;<b>HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED</b>
<br />
 }</td></tr>
<tr class="separator:abc3b93f68c8bdd857ad32913628dfa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2dc7bfb4ccb91c5d771f9e9ea237e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c2dc7bfb4ccb91c5d771f9e9ea237e1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lwsgs_auth_bits</b> { <b>LWSGS_AUTH_LOGGED_IN</b> = 1, 
<b>LWSGS_AUTH_ADMIN</b> = 2, 
<b>LWSGS_AUTH_VERIFIED</b> = 4, 
<b>LWSGS_AUTH_FORGOT_FLOW</b> = 8
 }</td></tr>
<tr class="separator:a7c2dc7bfb4ccb91c5d771f9e9ea237e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93946b3d921072209d5cd8cdfa5332e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa93946b3d921072209d5cd8cdfa5332e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lws_gs_event</b> { <b>LWSGSE_CREATED</b>, 
<b>LWSGSE_DELETED</b>
 }</td></tr>
<tr class="separator:aa93946b3d921072209d5cd8cdfa5332e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f55936dc165257a2e1f7d47bce89e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc9f55936dc165257a2e1f7d47bce89e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lws_ext_options_types</b> { <b>EXTARG_NONE</b>, 
<b>EXTARG_DEC</b>, 
<b>EXTARG_OPT_DEC</b>
 }</td></tr>
<tr class="separator:acc9f55936dc165257a2e1f7d47bce89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eca18e50cb4357480f2fcad36ff437"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437">lws_mount_protocols</a> { <br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437a1e9f0842b0e85db50fe648ed4ba9a4b0">LWSMPRO_HTTP</a> = 0, 
<a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437afbd10eb4777517ed1f6bfdcf3b9ea1d1">LWSMPRO_HTTPS</a> = 1, 
<a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437a42f2361cfe76cd287fa8fcfc502357e2">LWSMPRO_FILE</a> = 2, 
<a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437a13ab58b01ac6e05f595977f1e0f0db69">LWSMPRO_CGI</a> = 3, 
<br />
&#160;&#160;<a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437aec137a2434851bd856ceebfb697b9970">LWSMPRO_REDIR_HTTP</a> = 4, 
<a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437a8894d16316863077dfe530963ca59f67">LWSMPRO_REDIR_HTTPS</a> = 5, 
<a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437a946a88cf9c852eed2c0317f4115d19da">LWSMPRO_CALLBACK</a> = 6
<br />
 }</td></tr>
<tr class="separator:a31eca18e50cb4357480f2fcad36ff437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a74a822771d3dce89751aa3bce28ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41a74a822771d3dce89751aa3bce28ae"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>lws_spa_fileupload_states</b> { <b>LWS_UFS_CONTENT</b>, 
<b>LWS_UFS_FINAL_CONTENT</b>, 
<b>LWS_UFS_OPEN</b>
 }</td></tr>
<tr class="separator:a41a74a822771d3dce89751aa3bce28ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0aa4b9c3c55bae7b35cbfac3246c87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c0aa4b9c3c55bae7b35cbfac3246c87"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>pending_timeout</b> { <br />
&#160;&#160;<b>NO_PENDING_TIMEOUT</b> = 0, 
<b>PENDING_TIMEOUT_AWAITING_PROXY_RESPONSE</b> = 1, 
<b>PENDING_TIMEOUT_AWAITING_CONNECT_RESPONSE</b> = 2, 
<b>PENDING_TIMEOUT_ESTABLISH_WITH_SERVER</b> = 3, 
<br />
&#160;&#160;<b>PENDING_TIMEOUT_AWAITING_SERVER_RESPONSE</b> = 4, 
<b>PENDING_TIMEOUT_AWAITING_PING</b> = 5, 
<b>PENDING_TIMEOUT_CLOSE_ACK</b> = 6, 
<b>PENDING_TIMEOUT_AWAITING_EXTENSION_CONNECT_RESPONSE</b> = 7, 
<br />
&#160;&#160;<b>PENDING_TIMEOUT_SENT_CLIENT_HANDSHAKE</b> = 8, 
<b>PENDING_TIMEOUT_SSL_ACCEPT</b> = 9, 
<b>PENDING_TIMEOUT_HTTP_CONTENT</b> = 10, 
<b>PENDING_TIMEOUT_AWAITING_CLIENT_HS_SEND</b> = 11, 
<br />
&#160;&#160;<b>PENDING_FLUSH_STORED_SEND_BEFORE_CLOSE</b> = 12, 
<b>PENDING_TIMEOUT_SHUTDOWN_FLUSH</b> = 13, 
<b>PENDING_TIMEOUT_CGI</b> = 14, 
<b>PENDING_TIMEOUT_HTTP_KEEPALIVE_IDLE</b> = 15
<br />
 }</td></tr>
<tr class="separator:a2c0aa4b9c3c55bae7b35cbfac3246c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af5f07837692b2f231a79da8a058288aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5f07837692b2f231a79da8a058288aa"></a>
LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>_lws_log</b> (int filter, const char *format,...)</td></tr>
<tr class="separator:af5f07837692b2f231a79da8a058288aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74eb146969f0595e12ea835851b4588e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74eb146969f0595e12ea835851b4588e"></a>
LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>_lws_logv</b> (int filter, const char *format, va_list vl)</td></tr>
<tr class="separator:a74eb146969f0595e12ea835851b4588e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e39775c6b69b7251bdbf5a2cdd5dcd"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a42e39775c6b69b7251bdbf5a2cdd5dcd">lwsl_timestamp</a> (int level, char *p, int len)</td></tr>
<tr class="separator:a42e39775c6b69b7251bdbf5a2cdd5dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643073f918c0a7016b690aae9793fd60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a643073f918c0a7016b690aae9793fd60"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_chunked_html_process</b> (struct <a class="el" href="structlws__process__html__args.html">lws_process_html_args</a> *args, struct <a class="el" href="structlws__process__html__state.html">lws_process_html_state</a> *s)</td></tr>
<tr class="separator:a643073f918c0a7016b690aae9793fd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdbe42d872e21a448a947714d6c607e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cdbe42d872e21a448a947714d6c607e"></a>
LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_extension_callback_pm_deflate</b> (struct lws_context *context, const struct <a class="el" href="structlws__extension.html">lws_extension</a> *ext, struct lws *wsi, enum lws_extension_callback_reasons reason, void *user, void *in, size_t len)</td></tr>
<tr class="separator:a4cdbe42d872e21a448a947714d6c607e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e24e1768f83a7fb07896ce975704b9"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ae0e24e1768f83a7fb07896ce975704b9">lws_set_extension_option</a> (struct lws *wsi, const char *ext_name, const char *opt_name, const char *opt_val)</td></tr>
<tr class="separator:ae0e24e1768f83a7fb07896ce975704b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e6cc2223c4eec316b13bcebc3628b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94e6cc2223c4eec316b13bcebc3628b6"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_json_dump_vhost</b> (const struct lws_vhost *vh, char *buf, int len)</td></tr>
<tr class="separator:a94e6cc2223c4eec316b13bcebc3628b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2134657cdd2ea7a59e13ad314e4c50d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2134657cdd2ea7a59e13ad314e4c50d"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_json_dump_context</b> (const struct lws_context *context, char *buf, int len)</td></tr>
<tr class="separator:ae2134657cdd2ea7a59e13ad314e4c50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244647f9e1bf0097ccdde66d74f41e26"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a244647f9e1bf0097ccdde66d74f41e26">lws_set_log_level</a> (int level, void(*log_emit_function)(int level, const char *line))</td></tr>
<tr class="separator:a244647f9e1bf0097ccdde66d74f41e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c0fc936cc9f1eb58e2bb234c15147c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7c0fc936cc9f1eb58e2bb234c15147c"></a>
LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>lwsl_emit_syslog</b> (int level, const char *line)</td></tr>
<tr class="separator:ab7c0fc936cc9f1eb58e2bb234c15147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fff58562caab7510c41eeac85a8648"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2fff58562caab7510c41eeac85a8648"></a>
LWS_VISIBLE LWS_EXTERN struct lws_context *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_create_context</b> (struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> *info)</td></tr>
<tr class="separator:af2fff58562caab7510c41eeac85a8648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c54c667ccd9b8b3dddcd123ca72f87c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c54c667ccd9b8b3dddcd123ca72f87c"></a>
LWS_EXTERN LWS_VISIBLE struct lws_vhost *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_create_vhost</b> (struct lws_context *context, struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> *info)</td></tr>
<tr class="separator:a0c54c667ccd9b8b3dddcd123ca72f87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f44b8230e6732816ca5cd8d1aaaf340"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a4f44b8230e6732816ca5cd8d1aaaf340">lws_init_vhost_client_ssl</a> (const struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> *info, struct lws_vhost *vhost)</td></tr>
<tr class="separator:a4f44b8230e6732816ca5cd8d1aaaf340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25754726d97c5f519d313e691a9fe29d"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a25754726d97c5f519d313e691a9fe29d">lws_vhost_name_to_protocol</a> (struct lws_vhost *vh, const char *name)</td></tr>
<tr class="separator:a25754726d97c5f519d313e691a9fe29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db03e19a372e34ac25cf21af894a02c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8db03e19a372e34ac25cf21af894a02c"></a>
LWS_VISIBLE LWS_EXTERN struct lws_vhost *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_vhost_get</b> (struct lws *wsi) LWS_WARN_DEPRECATED</td></tr>
<tr class="separator:a8db03e19a372e34ac25cf21af894a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e77ce2916f8bc9826ef8d9d68e3932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06e77ce2916f8bc9826ef8d9d68e3932"></a>
LWS_VISIBLE LWS_EXTERN struct lws_vhost *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_vhost</b> (struct lws *wsi)</td></tr>
<tr class="separator:a06e77ce2916f8bc9826ef8d9d68e3932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bbe5e65faca068845704bab911a5030"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bbe5e65faca068845704bab911a5030"></a>
LWS_VISIBLE LWS_EXTERN const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_protocol_get</b> (struct lws *wsi) LWS_WARN_DEPRECATED</td></tr>
<tr class="separator:a8bbe5e65faca068845704bab911a5030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0c0477288ff3f83aff38d357b883d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec0c0477288ff3f83aff38d357b883d1"></a>
LWS_VISIBLE LWS_EXTERN void *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_protocol_vh_priv_zalloc</b> (struct lws_vhost *vhost, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *prot, int size)</td></tr>
<tr class="separator:aec0c0477288ff3f83aff38d357b883d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be4243443baac0f8be1fcfb4d25129"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3be4243443baac0f8be1fcfb4d25129"></a>
LWS_VISIBLE LWS_EXTERN void *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_protocol_vh_priv_get</b> (struct lws_vhost *vhost, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *prot)</td></tr>
<tr class="separator:af3be4243443baac0f8be1fcfb4d25129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106b37ae9c247e84d191ab09441adc43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a106b37ae9c247e84d191ab09441adc43"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_finalize_startup</b> (struct lws_context *context)</td></tr>
<tr class="separator:a106b37ae9c247e84d191ab09441adc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9d5405547a457d86e0b4f0ae2bb1c4"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a7e9d5405547a457d86e0b4f0ae2bb1c4">lws_set_proxy</a> (struct lws_vhost *vhost, const char *proxy)</td></tr>
<tr class="separator:a7e9d5405547a457d86e0b4f0ae2bb1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee0314028755f1ddfa9428e09b4fddb"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a8ee0314028755f1ddfa9428e09b4fddb">lws_context_destroy</a> (struct lws_context *context)</td></tr>
<tr class="separator:a8ee0314028755f1ddfa9428e09b4fddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95bd0c663d6516a0c80047d9b1167a8"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#af95bd0c663d6516a0c80047d9b1167a8">lws_service</a> (struct lws_context *context, int timeout_ms)</td></tr>
<tr class="separator:af95bd0c663d6516a0c80047d9b1167a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3cc4473fd8848e5bbee7f310712939"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b3cc4473fd8848e5bbee7f310712939"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_service_tsi</b> (struct lws_context *context, int timeout_ms, int tsi)</td></tr>
<tr class="separator:a9b3cc4473fd8848e5bbee7f310712939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c246707997ab7a466aa709aecd2d7b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a29c246707997ab7a466aa709aecd2d7b">lws_cancel_service_pt</a> (struct lws *wsi)</td></tr>
<tr class="separator:a29c246707997ab7a466aa709aecd2d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e3d0801dfda7960a7249dd559e68a2"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a53e3d0801dfda7960a7249dd559e68a2">lws_cancel_service</a> (struct lws_context *context)</td></tr>
<tr class="separator:a53e3d0801dfda7960a7249dd559e68a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869d8bdffb0f2a7ce08e3ce10d6be3d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a869d8bdffb0f2a7ce08e3ce10d6be3d8"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_interface_to_sa</b> (int ipv6, const char *ifname, struct sockaddr_in *addr, size_t addrlen)</td></tr>
<tr class="separator:a869d8bdffb0f2a7ce08e3ce10d6be3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0597b2ef1d2cee35736c338bcbd17b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c0597b2ef1d2cee35736c338bcbd17b"></a>
LWS_VISIBLE LWS_EXTERN const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_token_to_string</b> (enum lws_token_indexes token)</td></tr>
<tr class="separator:a2c0597b2ef1d2cee35736c338bcbd17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b36bf44405755ff51c1939303b995a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b36bf44405755ff51c1939303b995a8"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_add_http_header_by_name</b> (struct lws *wsi, const unsigned char *name, const unsigned char *value, int length, unsigned char **p, unsigned char *end)</td></tr>
<tr class="separator:a2b36bf44405755ff51c1939303b995a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4887605ff2242a54db3a7fa01f6f864b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4887605ff2242a54db3a7fa01f6f864b"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_finalize_http_header</b> (struct lws *wsi, unsigned char **p, unsigned char *end)</td></tr>
<tr class="separator:a4887605ff2242a54db3a7fa01f6f864b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74adb761b22566ad70004882712dce1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af74adb761b22566ad70004882712dce1"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_add_http_header_by_token</b> (struct lws *wsi, enum lws_token_indexes token, const unsigned char *value, int length, unsigned char **p, unsigned char *end)</td></tr>
<tr class="separator:af74adb761b22566ad70004882712dce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc76a5babcb4dce1b01b1955aa7a2faf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc76a5babcb4dce1b01b1955aa7a2faf"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_add_http_header_content_length</b> (struct lws *wsi, unsigned long content_length, unsigned char **p, unsigned char *end)</td></tr>
<tr class="separator:acc76a5babcb4dce1b01b1955aa7a2faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b7d6d2ddfdbaff3d8b607e7e3151b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b7d6d2ddfdbaff3d8b607e7e3151b6"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_add_http_header_status</b> (struct lws *wsi, unsigned int code, unsigned char **p, unsigned char *end)</td></tr>
<tr class="separator:a29b7d6d2ddfdbaff3d8b607e7e3151b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2888476e50e001c875c1a8abf455b7"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#abc2888476e50e001c875c1a8abf455b7">lws_urlencode</a> (char *escaped, const char *string, int len)</td></tr>
<tr class="separator:abc2888476e50e001c875c1a8abf455b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc82f06e5ae7e71458626d7a39a5865"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a9cc82f06e5ae7e71458626d7a39a5865">lws_sql_purify</a> (char *escaped, const char *string, int len)</td></tr>
<tr class="separator:a9cc82f06e5ae7e71458626d7a39a5865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15187efcfa256b7c928562c182b92a3"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ab15187efcfa256b7c928562c182b92a3">lws_json_purify</a> (char *escaped, const char *string, int len)</td></tr>
<tr class="separator:ab15187efcfa256b7c928562c182b92a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa373a9c16acdd96c395af61ab915ece3"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aa373a9c16acdd96c395af61ab915ece3">lws_urldecode</a> (char *string, const char *escaped, int len)</td></tr>
<tr class="separator:aa373a9c16acdd96c395af61ab915ece3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162f86762173a2bc8c28497941d74815"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws_spa *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a162f86762173a2bc8c28497941d74815">lws_spa_create</a> (struct lws *wsi, const char *const *param_names, int count_params, int max_storage, lws_spa_fileupload_cb opt_cb, void *opt_data)</td></tr>
<tr class="separator:a162f86762173a2bc8c28497941d74815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad217392f627774fd4f34c6e92b493d2a"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ad217392f627774fd4f34c6e92b493d2a">lws_spa_process</a> (struct lws_spa *ludspa, const char *in, int len)</td></tr>
<tr class="separator:ad217392f627774fd4f34c6e92b493d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb45918f9a0417540152c395f37150a7"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#adb45918f9a0417540152c395f37150a7">lws_spa_finalize</a> (struct lws_spa *ludspa)</td></tr>
<tr class="separator:adb45918f9a0417540152c395f37150a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae207309c4e5ea7a1485ca8bdc663cce0"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ae207309c4e5ea7a1485ca8bdc663cce0">lws_spa_get_length</a> (struct lws_spa *ludspa, int n)</td></tr>
<tr class="separator:ae207309c4e5ea7a1485ca8bdc663cce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65e00386b9188a53b4bdb62522a1f09"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ab65e00386b9188a53b4bdb62522a1f09">lws_spa_get_string</a> (struct lws_spa *ludspa, int n)</td></tr>
<tr class="separator:ab65e00386b9188a53b4bdb62522a1f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e2a32318f00c7797943681c91fceed"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a26e2a32318f00c7797943681c91fceed">lws_spa_destroy</a> (struct lws_spa *ludspa)</td></tr>
<tr class="separator:a26e2a32318f00c7797943681c91fceed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbf01e473ac421fc33ad9f8da8b8a25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fbf01e473ac421fc33ad9f8da8b8a25"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_http_redirect</b> (struct lws *wsi, int code, const unsigned char *loc, int len, unsigned char **p, unsigned char *end)</td></tr>
<tr class="separator:a8fbf01e473ac421fc33ad9f8da8b8a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27aed6c66a41b2b89ffe4da2a309e8a"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ad27aed6c66a41b2b89ffe4da2a309e8a">lws_http_transaction_completed</a> (struct lws *wsi)</td></tr>
<tr class="separator:ad27aed6c66a41b2b89ffe4da2a309e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82efa5466d14a9f05aa06416375b28d"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ad82efa5466d14a9f05aa06416375b28d">lws_service_fd</a> (struct lws_context *context, struct lws_pollfd *pollfd)</td></tr>
<tr class="separator:ad82efa5466d14a9f05aa06416375b28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf426eda371ba23642fc11d8e0ace6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf426eda371ba23642fc11d8e0ace6b"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_service_fd_tsi</b> (struct lws_context *context, struct lws_pollfd *pollfd, int tsi)</td></tr>
<tr class="separator:aebf426eda371ba23642fc11d8e0ace6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb12f934bfd178bd2132a9e73fc641da"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aeb12f934bfd178bd2132a9e73fc641da">lws_context_user</a> (struct lws_context *context)</td></tr>
<tr class="separator:aeb12f934bfd178bd2132a9e73fc641da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa194584fff9698f3b280658f770ccd0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa194584fff9698f3b280658f770ccd0f"></a>
LWS_VISIBLE LWS_EXTERN void *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_wsi_user</b> (struct lws *wsi)</td></tr>
<tr class="separator:aa194584fff9698f3b280658f770ccd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced9f9237f6172fed9f730a2af51345a"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aced9f9237f6172fed9f730a2af51345a">lws_set_timeout</a> (struct lws *wsi, enum pending_timeout reason, int secs)</td></tr>
<tr class="separator:aced9f9237f6172fed9f730a2af51345a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5fdd285a0e25ba7e3e1051deec1001"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#afd5fdd285a0e25ba7e3e1051deec1001">lws_write</a> (struct lws *wsi, unsigned char *buf, size_t len, enum <a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193d">lws_write_protocol</a> protocol)</td></tr>
<tr class="separator:afd5fdd285a0e25ba7e3e1051deec1001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c863415d1783cd8de7938aa6efa262"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aa1c863415d1783cd8de7938aa6efa262">lws_close_reason</a> (struct lws *wsi, enum <a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985">lws_close_status</a> status, unsigned char *buf, size_t len)</td></tr>
<tr class="separator:aa1c863415d1783cd8de7938aa6efa262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab393a06d3d2722af4c3f8b06842c80d7"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file</a> (struct lws *wsi, const char *file, const char *content_type, const char *other_headers, int other_headers_len)</td></tr>
<tr class="separator:ab393a06d3d2722af4c3f8b06842c80d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e1123f6d56cd777b3e5bf9ca40f9e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29e1123f6d56cd777b3e5bf9ca40f9e5"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_serve_http_file_fragment</b> (struct lws *wsi)</td></tr>
<tr class="separator:a29e1123f6d56cd777b3e5bf9ca40f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a4a71240857dc6b2ed70456b6923f4"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ac8a4a71240857dc6b2ed70456b6923f4">lws_return_http_status</a> (struct lws *wsi, unsigned int code, const char *html_body)</td></tr>
<tr class="separator:ac8a4a71240857dc6b2ed70456b6923f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ad550786ca7976463589d347e62112"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a72ad550786ca7976463589d347e62112">lws_get_protocol</a> (struct lws *wsi)</td></tr>
<tr class="separator:a72ad550786ca7976463589d347e62112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941caaa468bc507b1cae52275f58800d"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a941caaa468bc507b1cae52275f58800d">lws_callback_on_writable</a> (struct lws *wsi)</td></tr>
<tr class="separator:a941caaa468bc507b1cae52275f58800d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe4655c7eeb3eb1671b2323ec6b3107"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#abbe4655c7eeb3eb1671b2323ec6b3107">lws_callback_on_writable_all_protocol</a> (const struct lws_context *context, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol)</td></tr>
<tr class="separator:abbe4655c7eeb3eb1671b2323ec6b3107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8570860e191b62db264f2bac67354ea8"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a8570860e191b62db264f2bac67354ea8">lws_callback_on_writable_all_protocol_vhost</a> (const struct lws_vhost *vhost, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol)</td></tr>
<tr class="separator:a8570860e191b62db264f2bac67354ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf04bbe089f47c971c6408c5efe2ac70"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#acf04bbe089f47c971c6408c5efe2ac70">lws_callback_all_protocol</a> (struct lws_context *context, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol, int reason)</td></tr>
<tr class="separator:acf04bbe089f47c971c6408c5efe2ac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c984d8c5a44a745fd02bc2fba36053"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a13c984d8c5a44a745fd02bc2fba36053">lws_callback_all_protocol_vhost</a> (struct lws_vhost *vh, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol, int reason)</td></tr>
<tr class="separator:a13c984d8c5a44a745fd02bc2fba36053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60939cf0c073d933fde3d17f3591caf5"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a60939cf0c073d933fde3d17f3591caf5">lws_callback_vhost_protocols</a> (struct lws *wsi, int reason, void *in, int len)</td></tr>
<tr class="separator:a60939cf0c073d933fde3d17f3591caf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa709e02a10558753c851e58f1e2c16ba"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aa709e02a10558753c851e58f1e2c16ba">lws_get_socket_fd</a> (struct lws *wsi)</td></tr>
<tr class="separator:aa709e02a10558753c851e58f1e2c16ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e9ee165fca503fd9427d55cfecac37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08e9ee165fca503fd9427d55cfecac37"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_is_final_fragment</b> (struct lws *wsi)</td></tr>
<tr class="separator:a08e9ee165fca503fd9427d55cfecac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df5045656dfb6b0e63a38de2dca79d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3df5045656dfb6b0e63a38de2dca79d2"></a>
LWS_VISIBLE LWS_EXTERN unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_reserved_bits</b> (struct lws *wsi)</td></tr>
<tr class="separator:a3df5045656dfb6b0e63a38de2dca79d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4abd01e8c43f07c6e498ce13590c3e"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#adf4abd01e8c43f07c6e498ce13590c3e">lws_rx_flow_control</a> (struct lws *wsi, int enable)</td></tr>
<tr class="separator:adf4abd01e8c43f07c6e498ce13590c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e627dbf1db48170ef486edbaf268672"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a5e627dbf1db48170ef486edbaf268672">lws_rx_flow_allow_all_protocol</a> (const struct lws_context *context, const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *protocol)</td></tr>
<tr class="separator:a5e627dbf1db48170ef486edbaf268672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fe65e83b8bb03f904a1a256c673536"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a72fe65e83b8bb03f904a1a256c673536">lws_remaining_packet_payload</a> (struct lws *wsi)</td></tr>
<tr class="separator:a72fe65e83b8bb03f904a1a256c673536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4643fe16b0940ae5b68b4ee6195cbde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4643fe16b0940ae5b68b4ee6195cbde"></a>
LWS_VISIBLE LWS_EXTERN size_t&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_peer_write_allowance</b> (struct lws *wsi)</td></tr>
<tr class="separator:ac4643fe16b0940ae5b68b4ee6195cbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af0a20108a95e8b6d94dd4d80055ff3"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a4af0a20108a95e8b6d94dd4d80055ff3">lws_client_connect</a> (struct lws_context *clients, const char *address, int port, int ssl_connection, const char *path, const char *host, const char *origin, const char *protocol, int ietf_version_or_minus_one) LWS_WARN_DEPRECATED</td></tr>
<tr class="separator:a4af0a20108a95e8b6d94dd4d80055ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a8558b4410961a880241c2ac1271e2"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ac6a8558b4410961a880241c2ac1271e2">lws_client_connect_extended</a> (struct lws_context *clients, const char *address, int port, int ssl_connection, const char *path, const char *host, const char *origin, const char *protocol, int ietf_version_or_minus_one, void *userdata) LWS_WARN_DEPRECATED</td></tr>
<tr class="separator:ac6a8558b4410961a880241c2ac1271e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30a7be106abd0cedfbb2e8b8fe3a2f5"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ac30a7be106abd0cedfbb2e8b8fe3a2f5">lws_client_connect_via_info</a> (struct <a class="el" href="structlws__client__connect__info.html">lws_client_connect_info</a> *ccinfo)</td></tr>
<tr class="separator:ac30a7be106abd0cedfbb2e8b8fe3a2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe71b7462afb21c767bdc67334f305af"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#abe71b7462afb21c767bdc67334f305af">lws_adopt_socket</a> (struct lws_context *context, lws_sockfd_type accept_fd)</td></tr>
<tr class="separator:abe71b7462afb21c767bdc67334f305af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d045df0f81afe00891aaed312d552b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ab2d045df0f81afe00891aaed312d552b">lws_adopt_socket_readbuf</a> (struct lws_context *context, lws_sockfd_type accept_fd, const char *readbuf, size_t len)</td></tr>
<tr class="separator:ab2d045df0f81afe00891aaed312d552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0df22db2be9fc65a667a1e83f9a92a4"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const char *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#ad0df22db2be9fc65a667a1e83f9a92a4">lws_canonical_hostname</a> (struct lws_context *context)</td></tr>
<tr class="separator:ad0df22db2be9fc65a667a1e83f9a92a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">and @rip with the name and IP of</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>lws_get_peer_addresses() - Get client address information </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Local struct lws associated with </td></tr>
    <tr><td class="paramname">fd</td><td>Connection socket descriptor </td></tr>
    <tr><td class="paramname">name</td><td>Buffer to take client address name </td></tr>
    <tr><td class="paramname">name_len</td><td>Length of client address name buffer </td></tr>
    <tr><td class="paramname">rip</td><td>Buffer to take client address IP dotted quad </td></tr>
    <tr><td class="paramname">rip_len</td><td>Length of client address IP buffer <pre class="fragment"> This function fills in
 the client connected with socket descriptor @fd.  Names may be
 truncated if there is not enough room.  If either cannot be
 determined, they will be returned as valid zero-length strings.</pre> </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:a092e5f473b3347f03ffeef8a950080f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a092e5f473b3347f03ffeef8a950080f3"></a>
LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_peer_addresses</b> (struct lws *wsi, lws_sockfd_type fd, char *name, int name_len, char *rip, int rip_len)</td></tr>
<tr class="separator:a092e5f473b3347f03ffeef8a950080f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">from the</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>lws_get_peer_simple() - Get client address information without RDNS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Local struct lws associated with </td></tr>
    <tr><td class="paramname">name</td><td>Buffer to take client address name </td></tr>
    <tr><td class="paramname">name_len</td><td>Length of client address name buffer <pre class="fragment">    This provides a 123.123.123.123 type IP address in
    peer that has connected to @wsi</pre> </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:ad01014fed09759741b6d23afccfdaacc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad01014fed09759741b6d23afccfdaacc"></a>
LWS_VISIBLE LWS_EXTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_peer_simple</b> (struct lws *wsi, char *name, int namelen)</td></tr>
<tr class="separator:ad01014fed09759741b6d23afccfdaacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f906c6be0ca80efd813f694569dd4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58f906c6be0ca80efd813f694569dd4a"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_random</b> (struct lws_context *context, void *buf, int len)</td></tr>
<tr class="separator:a58f906c6be0ca80efd813f694569dd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5171b1dbbc03ec89a98f8afdb5c9af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace5171b1dbbc03ec89a98f8afdb5c9af"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_daemonize</b> (const char *_lock_path)</td></tr>
<tr class="separator:ace5171b1dbbc03ec89a98f8afdb5c9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb3655329b4651cd06f79ee3a764421"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bb3655329b4651cd06f79ee3a764421"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_send_pipe_choked</b> (struct lws *wsi)</td></tr>
<tr class="separator:a2bb3655329b4651cd06f79ee3a764421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca4afc94b1f026034f99cbba37e2f85"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aeca4afc94b1f026034f99cbba37e2f85">lws_partial_buffered</a> (struct lws *wsi)</td></tr>
<tr class="separator:aeca4afc94b1f026034f99cbba37e2f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd9c59336efad8af0554f79cc5966fd"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#accd9c59336efad8af0554f79cc5966fd">lws_frame_is_binary</a> (struct lws *wsi)</td></tr>
<tr class="separator:accd9c59336efad8af0554f79cc5966fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a140623d202dd2bf2004deb6994baa"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a26a140623d202dd2bf2004deb6994baa">lws_is_ssl</a> (struct lws *wsi)</td></tr>
<tr class="separator:a26a140623d202dd2bf2004deb6994baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad226d5e01024b4046f4a5a37199aa1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ad226d5e01024b4046f4a5a37199aa1"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_is_cgi</b> (struct lws *wsi)</td></tr>
<tr class="separator:a4ad226d5e01024b4046f4a5a37199aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b09ab74646266f0b555103b3bb8dfe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b09ab74646266f0b555103b3bb8dfe5"></a>
LWS_VISIBLE LWS_EXTERN unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><b>lws_SHA1</b> (const unsigned char *d, size_t n, unsigned char *md)</td></tr>
<tr class="separator:a7b09ab74646266f0b555103b3bb8dfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39765e4a3b413efb65e4698b2ec3575"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39765e4a3b413efb65e4698b2ec3575"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_b64_encode_string</b> (const char *in, int in_len, char *out, int out_size)</td></tr>
<tr class="separator:af39765e4a3b413efb65e4698b2ec3575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66316e6a5a0644a09d5a10e919dfdd8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66316e6a5a0644a09d5a10e919dfdd8d"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_b64_decode_string</b> (const char *in, char *out, int out_size)</td></tr>
<tr class="separator:a66316e6a5a0644a09d5a10e919dfdd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6abfc0b2bd5b2f09281a4432bb2f5f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6abfc0b2bd5b2f09281a4432bb2f5f0"></a>
LWS_VISIBLE LWS_EXTERN const char *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_library_version</b> (void)</td></tr>
<tr class="separator:ac6abfc0b2bd5b2f09281a4432bb2f5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec0d9faac5d3a5824d765c287c043aa"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a1ec0d9faac5d3a5824d765c287c043aa">lws_parse_uri</a> (char *p, const char **prot, const char **ads, int *port, const char **path)</td></tr>
<tr class="separator:a1ec0d9faac5d3a5824d765c287c043aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ade0e1ffb0da7e62b989d8d867bf6c8"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length</a> (struct lws *wsi, enum lws_token_indexes h)</td></tr>
<tr class="separator:a8ade0e1ffb0da7e62b989d8d867bf6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594f3d0ece5b09c2ccf9f98ea533bb4e"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a594f3d0ece5b09c2ccf9f98ea533bb4e">lws_hdr_fragment_length</a> (struct lws *wsi, enum lws_token_indexes h, int frag_idx)</td></tr>
<tr class="separator:a594f3d0ece5b09c2ccf9f98ea533bb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce6aa1c0155ea42b7708bed271d1c77"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy</a> (struct lws *wsi, char *dest, int len, enum lws_token_indexes h)</td></tr>
<tr class="separator:a6ce6aa1c0155ea42b7708bed271d1c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa427cad61a9a5e3004afd65c4527b5e9"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#aa427cad61a9a5e3004afd65c4527b5e9">lws_hdr_copy_fragment</a> (struct lws *wsi, char *dest, int len, enum lws_token_indexes h, int frag_idx)</td></tr>
<tr class="separator:aa427cad61a9a5e3004afd65c4527b5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e9ce5e71a77501a0998ac403a984c2"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a84e9ce5e71a77501a0998ac403a984c2">lws_get_urlarg_by_name</a> (struct lws *wsi, const char *name, char *buf, int len)</td></tr>
<tr class="separator:a84e9ce5e71a77501a0998ac403a984c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bf2635033710b25f931b57ed663e1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33bf2635033710b25f931b57ed663e1e"></a>
LWS_VISIBLE LWS_EXTERN unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>lws_now_secs</b> (void)</td></tr>
<tr class="separator:a33bf2635033710b25f931b57ed663e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08aef64c4c34647ed699b24759b6b0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac08aef64c4c34647ed699b24759b6b0e"></a>
LWS_VISIBLE LWS_EXTERN struct <a class="el" href="structlws__plat__file__ops.html">lws_plat_file_ops</a> *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_fops</b> (struct lws_context *context)</td></tr>
<tr class="separator:ac08aef64c4c34647ed699b24759b6b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af4f7d2dd375aeedcfa7eb0e1101c4b"><td class="memItemLeft" align="right" valign="top">LWS_VISIBLE LWS_EXTERN struct lws_context *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="libwebsockets_8h.html#a0af4f7d2dd375aeedcfa7eb0e1101c4b">lws_get_context</a> (const struct lws *wsi)</td></tr>
<tr class="separator:a0af4f7d2dd375aeedcfa7eb0e1101c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629f48268fd1856b54b11172991b97d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a629f48268fd1856b54b11172991b97d9"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_count_threads</b> (struct lws_context *context)</td></tr>
<tr class="separator:a629f48268fd1856b54b11172991b97d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8930fe36a3f3eefe4a6a4fd499d8e899"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8930fe36a3f3eefe4a6a4fd499d8e899"></a>
LWS_VISIBLE LWS_EXTERN struct lws *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_parent</b> (const struct lws *wsi)</td></tr>
<tr class="separator:a8930fe36a3f3eefe4a6a4fd499d8e899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae4d7b6a8d22e4c2d82ff8b12c1e234"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acae4d7b6a8d22e4c2d82ff8b12c1e234"></a>
LWS_VISIBLE LWS_EXTERN struct lws *LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_get_child</b> (const struct lws *wsi)</td></tr>
<tr class="separator:acae4d7b6a8d22e4c2d82ff8b12c1e234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4450c34200bf9dab3beb90ef23221870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4450c34200bf9dab3beb90ef23221870"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_http_client_read</b> (struct lws *wsi, char **buf, int *len)</td></tr>
<tr class="separator:a4450c34200bf9dab3beb90ef23221870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d88c9080fd89c37114363a6474ea73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98d88c9080fd89c37114363a6474ea73"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lwsws_get_config_globals</b> (struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> *info, const char *d, char **config_strings, int *len)</td></tr>
<tr class="separator:a98d88c9080fd89c37114363a6474ea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341064721add2618ae1b29717493a212"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a341064721add2618ae1b29717493a212"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lwsws_get_config_vhosts</b> (struct lws_context *context, struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> *info, const char *d, char **config_strings, int *len)</td></tr>
<tr class="separator:a341064721add2618ae1b29717493a212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e705d498e8c8500649a26ba30a1e106"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e705d498e8c8500649a26ba30a1e106"></a>
LWS_VISIBLE LWS_EXTERN int&#160;</td><td class="memItemRight" valign="bottom"><b>lws_read</b> (struct lws *wsi, unsigned char *buf, size_t len)</td></tr>
<tr class="separator:a0e705d498e8c8500649a26ba30a1e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb3e2c3dfb9d64dc87026a4e99c128b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fb3e2c3dfb9d64dc87026a4e99c128b"></a>
LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>lws_ext_parse_options</b> (const struct <a class="el" href="structlws__extension.html">lws_extension</a> *ext, struct lws *wsi, void *ext_user, const struct <a class="el" href="structlws__ext__options.html">lws_ext_options</a> *opts, const char *o, int len)</td></tr>
<tr class="separator:a6fb3e2c3dfb9d64dc87026a4e99c128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab321ed812f46f6dc7ef9e3ca6f00cf1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab321ed812f46f6dc7ef9e3ca6f00cf1b"></a>
LWS_VISIBLE LWS_EXTERN void&#160;</td><td class="memItemRight" valign="bottom"><b>lws_set_allocator</b> (void *(*realloc)(void *ptr, size_t size))</td></tr>
<tr class="separator:ab321ed812f46f6dc7ef9e3ca6f00cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ab75ea60043f76634f5b05a7eeb633394"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _LWS_PAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(((n) % _LWS_PAD_SIZE) ? \</div><div class="line">                ((n) + (_LWS_PAD_SIZE - ((n) % _LWS_PAD_SIZE))) : (n))</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad4fcb82e68d60ffacca61a3f783a0a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_callback_function(struct lws *wsi, enum <a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a> reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="libwebsockets_8h.html#ad4fcb82e68d60ffacca61a3f783a0a2f">lws_callback_function()</a> - User server actions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons <pre class="fragment"> This callback is the way the user controls what is served.  All the
 protocol detail is hidden and handled by the library.

 For each connection / session there is user data allocated that is
 pointed to by "user".  You set the size of this user data area when
 the library is initialized with lws_create_server.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae7169b2cd346b34fa33d0250db2afd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int lws_extension_callback_function(struct lws_context *context, const struct <a class="el" href="structlws__extension.html">lws_extension</a> *ext, struct lws *wsi, enum lws_extension_callback_reasons reason, void *user, void *in, size_t len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>typedef <a class="el" href="libwebsockets_8h.html#aae7169b2cd346b34fa33d0250db2afd0">lws_extension_callback_function()</a> - Hooks to allow extensions to operate </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websockets context </td></tr>
    <tr><td class="paramname">ext</td><td>This extension </td></tr>
    <tr><td class="paramname">wsi</td><td>Opaque websocket instance pointer </td></tr>
    <tr><td class="paramname">reason</td><td>The reason for the call </td></tr>
    <tr><td class="paramname">user</td><td>Pointer to ptr to per-session user data allocated by library </td></tr>
    <tr><td class="paramname">in</td><td>Pointer used for some callback reasons </td></tr>
    <tr><td class="paramname">len</td><td>Length set for some callback reasons <pre class="fragment"> Each extension that is active on a particular connection receives
 callbacks during the connection lifetime to allow the extension to
 operate on websocket data and manage itself.

 Libwebsockets takes care of allocating and freeing "user" memory for
 each active extension on each connection.  That is what is pointed to
 by the @user parameter.

 LWS_EXT_CB_CONSTRUCT:  called when the server has decided to
    select this extension from the list provided by the client,
    just before the server will send back the handshake accepting
    the connection with this extension active.  This gives the
    extension a chance to initialize its connection context found
    in @user.

 LWS_EXT_CB_CLIENT_CONSTRUCT: same as LWS_EXT_CB_CONSTRUCT
    but called when client is instantiating this extension.  Some
    extensions will work the same on client and server side and then
    you can just merge handlers for both CONSTRUCTS.

 LWS_EXT_CB_DESTROY:  called when the connection the extension was
    being used on is about to be closed and deallocated.  It's the
    last chance for the extension to deallocate anything it has
    allocated in the user data (pointed to by @user) before the
    user data is deleted.  This same callback is used whether you
    are in client or server instantiation context.

 LWS_EXT_CB_PACKET_RX_PREPARSE: when this extension was active on
    a connection, and a packet of data arrived at the connection,
    it is passed to this callback to give the extension a chance to
    change the data, eg, decompress it.  @user is pointing to the
    extension's private connection context data, @in is pointing
    to an lws_tokens struct, it consists of a char * pointer called
    token, and an int called token_len.  At entry, these are
    set to point to the received buffer and set to the content
    length.  If the extension will grow the content, it should use
    a new buffer allocated in its private user context data and
    set the pointed-to lws_tokens members to point to its buffer.

 LWS_EXT_CB_PACKET_TX_PRESEND: this works the same way as
    LWS_EXT_CB_PACKET_RX_PREPARSE above, except it gives the
    extension a chance to change websocket data just before it will
    be sent out.  Using the same lws_token pointer scheme in @in,
    the extension can change the buffer and the length to be
    transmitted how it likes.  Again if it wants to grow the
    buffer safely, it should copy the data into its own buffer and
    set the lws_tokens token pointer to it.

 LWS_EXT_CB_ARGS_VALIDATE:</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libwebsockets_8h.html#ad62860e19975ba4c4af401c3cdb6abf7">lws_callback_reasons</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_callback_reasons - reason you're getting a protocol callback </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a24d39bf1cfc0bad9d92da9ac1717e439"></a>LWS_CALLBACK_ESTABLISHED&#160;</td><td class="fielddoc">
<p>(VH) after the server completes a handshake with an incoming client. If you built the library with ssl support,  is a pointer to the ssl struct associated with the connection or NULL. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ad8c6207b0c4e732f3d507f0fb79370e8"></a>LWS_CALLBACK_CLIENT_CONNECTION_ERROR&#160;</td><td class="fielddoc">
<p>the request client connection has been unable to complete a handshake with the remote server. If in is non-NULL, you can find an error string of length len where it points to. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7aa536e574a642ff3ab9e12bff7ba2c6a2"></a>LWS_CALLBACK_CLIENT_FILTER_PRE_ESTABLISH&#160;</td><td class="fielddoc">
<p>this is the last chance for the client user code to examine the http headers and decide to reject the connection. If the content in the headers is interesting to the client (url, etc) it needs to copy it out at this point <a class="el" href="protocolsince-p.html">since</a> it will be destroyed before the CLIENT_ESTABLISHED call </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a7e12418eec9bce85735e6460176ab604"></a>LWS_CALLBACK_CLIENT_ESTABLISHED&#160;</td><td class="fielddoc">
<p>after your client connection completed a handshake with the remote server </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a48a9590e5e18c7920282e094a0bfd9d8"></a>LWS_CALLBACK_CLOSED&#160;</td><td class="fielddoc">
<p>when the websocket session ends </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a838b18d255c1b94a533287ba302a2eba"></a>LWS_CALLBACK_CLOSED_HTTP&#160;</td><td class="fielddoc">
<p>when a HTTP (non-websocket) session ends </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a492c1b1c0ac0ed980042ee732fe2990c"></a>LWS_CALLBACK_RECEIVE&#160;</td><td class="fielddoc">
<p>data has appeared for this server endpoint from a remote client, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a2db02fc6e1c17ab62b52109d1aa9d738"></a>LWS_CALLBACK_RECEIVE_PONG&#160;</td><td class="fielddoc">
<p>servers receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7abbbe7a0a67c5866ca9109d46823fc5b1"></a>LWS_CALLBACK_CLIENT_RECEIVE&#160;</td><td class="fielddoc">
<p>data has appeared from the server for the client connection, it can be found at *in and is len bytes long </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a136a7cec11c3afd13245623bd84e76c9"></a>LWS_CALLBACK_CLIENT_RECEIVE_PONG&#160;</td><td class="fielddoc">
<p>clients receive PONG packets with this callback reason </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a8e8b2e6dbeac76d8d126947d2166a514"></a>LWS_CALLBACK_CLIENT_WRITEABLE&#160;</td><td class="fielddoc">
<p>If you call <a class="el" href="libwebsockets_8h.html#a941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> on a connection, you will get one of these callbacks coming when the connection socket is able to accept another write packet without blocking. If it already was able to take another packet without blocking, you'll get this callback at the next call to the service loop function. Notice that CLIENTs get LWS_CALLBACK_CLIENT_WRITEABLE and servers get LWS_CALLBACK_SERVER_WRITEABLE. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a7ec8e2e9557ee02a4fc9f7dec7e2babc"></a>LWS_CALLBACK_SERVER_WRITEABLE&#160;</td><td class="fielddoc">
<p>See LWS_CALLBACK_CLIENT_WRITEABLE </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ae8d1de0bb56e03aa58cb4d44b18edd2e"></a>LWS_CALLBACK_HTTP&#160;</td><td class="fielddoc">
<p>an http request has come from a client that is not asking to upgrade the connection to a websocket one. This is a chance to serve http content, for example, to send a script to the client which will then open the websockets connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>points to the URI path requested and <a class="el" href="libwebsockets_8h.html#ab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> makes it very simple to send back a file to the client. Normally after sending the file you are done with the http connection, <a class="el" href="protocolsince-p.html">since</a> the rest of the activity will come by websockets from the script that was delivered by http, so you will want to return 1; to close and free up the connection. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ac4c68e00efcf1ff7bda7ada462aff8ae"></a>LWS_CALLBACK_HTTP_BODY&#160;</td><td class="fielddoc">
<p>the next  bytes data from the http request body HTTP connection is now available in . </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a2fce9a8608220f32abbf1422a5498804"></a>LWS_CALLBACK_HTTP_BODY_COMPLETION&#160;</td><td class="fielddoc">
<p>the expected amount of http request body has been delivered </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7aa627548e1296e654fcfab463ec3c9587"></a>LWS_CALLBACK_HTTP_FILE_COMPLETION&#160;</td><td class="fielddoc">
<p>a file requested to be sent down http link has completed. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7afedadfb3cde37a8ea4c84ed535f26d09"></a>LWS_CALLBACK_HTTP_WRITEABLE&#160;</td><td class="fielddoc">
<p>you can write more down the http protocol link now. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a026502768778b8d79d62dd0fe4375fc6"></a>LWS_CALLBACK_FILTER_NETWORK_CONNECTION&#160;</td><td class="fielddoc">
<p>called when a client connects to the server at network level; the connection is accepted but then passed to this callback to decide whether to hang up immediately or not, based on the client IP.  contains the connection socket's descriptor. Since the client connection information is not available yet,  still pointing to the main server socket. Return non-zero to terminate the connection before sending or receiving anything. Because this happens immediately after the network connection from the client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a75199176c82c1a56e4a6bbf1cc30c12c"></a>LWS_CALLBACK_FILTER_HTTP_CONNECTION&#160;</td><td class="fielddoc">
<p>called when the request has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>is a pointer to the connection user space allocation, </td></tr>
    <tr><td class="paramname">in</td><td>is the URI, eg, "/" In your handler you can use the public APIs <a class="el" href="libwebsockets_8h.html#a8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="libwebsockets_8h.html#a6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from <a class="el" href="libwebsockets_8h.html">libwebsockets.h</a> to check for and read the supported header presence and content before deciding to allow the http connection to proceed or to kill the connection. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ae9734e1d7af2abf291665ce9e4a728d3"></a>LWS_CALLBACK_SERVER_NEW_CLIENT_INSTANTIATED&#160;</td><td class="fielddoc">
<p>A new client just had been connected, accepted, and instantiated into the pool. This callback allows setting any relevant property to it. Because this happens immediately after the instantiation of a new client, there's no websocket protocol selected yet so this callback is issued only to protocol 0. Only  is defined, pointing to the new client, and the return value is ignored. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7accd8753672d319a30b4b4c2fb775e84d"></a>LWS_CALLBACK_FILTER_PROTOCOL_CONNECTION&#160;</td><td class="fielddoc">
<p>called when the handshake has been received and parsed from the client, but the response is not sent yet. Return non-zero to disallow the connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>is a pointer to the connection user space allocation, </td></tr>
    <tr><td class="paramname">in</td><td>is the requested protocol name In your handler you can use the public APIs <a class="el" href="libwebsockets_8h.html#a8ade0e1ffb0da7e62b989d8d867bf6c8">lws_hdr_total_length()</a> / <a class="el" href="libwebsockets_8h.html#a6ce6aa1c0155ea42b7708bed271d1c77">lws_hdr_copy()</a> to access all of the headers using the header enums lws_token_indexes from <a class="el" href="libwebsockets_8h.html">libwebsockets.h</a> to check for and read the supported header presence and content before deciding to allow the handshake to proceed or to kill the connection. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ae4986291b7a810fe290851d73bebeb1c"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_CLIENT_VERIFY_CERTS&#160;</td><td class="fielddoc">
<p>if configured for including OpenSSL support, this callback allows your user code to perform extra SSL_CTX_load_verify_locations() or similar calls to direct OpenSSL where to find certificates the client can use to confirm the remote server identity.  is the OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a06006e98d27e1e884364d88317f83493"></a>LWS_CALLBACK_OPENSSL_LOAD_EXTRA_SERVER_VERIFY_CERTS&#160;</td><td class="fielddoc">
<p>if configured for including OpenSSL support, this callback allows your user code to load extra certifcates into the server which allow it to verify the validity of certificates returned by clients.  is the server's OpenSSL SSL_CTX* </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ae5ad65d779b7eab32ab67ceff91a3bac"></a>LWS_CALLBACK_OPENSSL_PERFORM_CLIENT_CERT_VERIFICATION&#160;</td><td class="fielddoc">
<p>if the libwebsockets vhost was created with the option LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT, then this callback is generated during OpenSSL verification of the cert sent from the client. It is sent to protocol[0] callback as no protocol has been negotiated on the connection yet. Notice that the libwebsockets context and wsi are both NULL during this callback. See <a href="http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html">http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html</a> to understand more detail about the OpenSSL callback that generates this libwebsockets callback and the meanings of the arguments passed. In this callback,  is the x509_ctx, </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is the ssl pointer and  is preverify_ok Notice that this callback maintains libwebsocket return conventions, return 0 to mean the cert is OK or 1 to fail it. This also means that if you don't handle this callback then the default callback action of returning 0 allows the client certificates. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a909cc2a7018864b0b71abacc4058fd8f"></a>LWS_CALLBACK_CLIENT_APPEND_HANDSHAKE_HEADER&#160;</td><td class="fielddoc">
<p>this callback happens when a client handshake is being compiled.  is NULL, </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is a char **, it's pointing to a char * which holds the next location in the header buffer where you can add headers, and  is the remaining space in the header buffer, which is typically some hundreds of bytes. So, to add a canned cookie, your handler code might look similar to: <pre class="fragment"> char **p = (char **)in;

 if (len &lt; 100)
    return 1;

 *p += sprintf(*p, "Cookie: a=b\x0d\x0a");

 return 0;
</pre></td></tr>
  </table>
  </dd>
</dl>
<p>Notice if you add anything, you just have to take care about the CRLF on the line you added. Obviously this callback is optional, if you don't handle it everything is fine.</p>
<p>Notice the callback is coming to protocols[0] all the time, because there is no specific protocol negotiated yet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a390da3639296660a78cc1a5dcb19037e"></a>LWS_CALLBACK_CONFIRM_EXTENSION_OKAY&#160;</td><td class="fielddoc">
<p>When the server handshake code sees that it does support a requested extension, before accepting the extension by additing to the list sent back to the client it gives this callback just to check that it's okay to use that extension. It calls back to the requested protocol and with  being the extension name,  is 0 and  is valid. Note though at this time the ESTABLISHED callback hasn't happened yet so if you initialize  content there,  content during this callback might not be useful for anything. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a1ce5b22039ca37ee224d00047596ea46"></a>LWS_CALLBACK_CLIENT_CONFIRM_EXTENSION_SUPPORTED&#160;</td><td class="fielddoc">
<p>When a client connection is being prepared to start a handshake to a server, each supported extension is checked with protocols[0] callback with this reason, giving the user code a chance to suppress the claim to support that extension by returning non-zero. If unhandled, by default 0 will be returned and the extension support included in the header to the server. Notice this callback comes to protocols[0]. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ad5d34583e3556e153eda91620b48cc49"></a>LWS_CALLBACK_PROTOCOL_INIT&#160;</td><td class="fielddoc">
<p>One-time call per protocol, per-vhost using it, so it can do initial setup / allocations etc </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a54269ca88508e6efd3afdb9d360a9caa"></a>LWS_CALLBACK_PROTOCOL_DESTROY&#160;</td><td class="fielddoc">
<p>One-time call per protocol, per-vhost using it, indicating this protocol won't get used at all after this callback, the vhost is getting destroyed. Take the opportunity to deallocate everything that was allocated by the protocol. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7afd8fd77a1cc9405fcb4f26915d7f2d01"></a>LWS_CALLBACK_WSI_CREATE&#160;</td><td class="fielddoc">
<p>outermost (earliest) wsi create notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7aca834dc035b7f7486f9ce40fde54fe9e"></a>LWS_CALLBACK_WSI_DESTROY&#160;</td><td class="fielddoc">
<p>outermost (latest) wsi destroy notification to protocols[0] </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7adfb41c92e2522712207ef7f2462b5e34"></a>LWS_CALLBACK_GET_THREAD_ID&#160;</td><td class="fielddoc">
<p>lws can accept callback when writable requests from other threads, if you implement this callback and return an opaque current thread ID integer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ab69783a9fbf2ca71ad70706bda77b412"></a>LWS_CALLBACK_ADD_POLL_FD&#160;</td><td class="fielddoc">
<p>lws normally deals with its poll() or other event loop internally, but in the case you are integrating with another server you will need to have lws sockets share a polling array with the other server. This and the other POLL_FD related callbacks let you put your specialized poll array interface code in the callback for protocol 0, the first protocol you support, usually the HTTP protocol in the serving case. This callback happens when a socket needs to be added to the polling loop:  points to a struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a>; the  member of the struct is the file descriptor, and  contains the active events</p>
<p>If you are using the internal lws polling / event loop you can just ignore these callbacks. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a1df60f314710236f9b53efbf468da768"></a>LWS_CALLBACK_DEL_POLL_FD&#160;</td><td class="fielddoc">
<p>This callback happens when a socket descriptor needs to be removed from an external polling array.  is again the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> containing the  member to be removed. If you are using the internal polling loop, you can just ignore it. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7aa87d2e82fffa42c3680c7403ef94216e"></a>LWS_CALLBACK_CHANGE_MODE_POLL_FD&#160;</td><td class="fielddoc">
<p>This callback happens when lws wants to modify the events for a connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>is the struct <a class="el" href="structlws__pollargs.html">lws_pollargs</a> with the  to change. The new event mask is in  member and the old mask is in the  member. If you are using the internal polling loop, you can just ignore it. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a8909732521d379179003d97ab7a05428"></a>LWS_CALLBACK_LOCK_POLL&#160;</td><td class="fielddoc">
<p>These allow the external poll changes driven by lws to participate in an external thread locking scheme around the changes, so the whole thing is threadsafe. These are called around three activities in the library,</p><ul>
<li>inserting a new wsi in the wsi / fd table (len=1)</li>
<li>deleting a wsi from the wsi / fd table (len=1)</li>
<li>changing a wsi's POLLIN/OUT state (len=0) Locking and unlocking external synchronization objects when len == 1 allows external threads to be synchronized against wsi lifecycle changes if it acquires the same lock for the duration of wsi dereference from the other thread context. </li>
</ul>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a0e9e3dd667c0c42cdbe1a3d921f4fd79"></a>LWS_CALLBACK_UNLOCK_POLL&#160;</td><td class="fielddoc">
<p>See LWS_CALLBACK_LOCK_POLL, ignore if using lws internal poll </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7aa46f705dcf97502e95627ffde614f98b"></a>LWS_CALLBACK_OPENSSL_CONTEXT_REQUIRES_PRIVATE_KEY&#160;</td><td class="fielddoc">
<p>if configured for including OpenSSL support but no private key file has been specified (ssl_private_key_filepath is NULL), this is called to allow the user to set the private key directly via libopenssl and perform further operations if required; this might be useful in situations where the private key is not directly accessible by the OS, for example if it is stored on a smartcard. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user</td><td>is the server's OpenSSL SSL_CTX* </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7ac3fc5bbb55e69f90396526287ee84a51"></a>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE&#160;</td><td class="fielddoc">
<p>The peer has sent an unsolicited Close WS packet.  and </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>are the optional close code (first 2 bytes, network order) and the optional additional information which is not defined in the standard, and may be a string or non-human- readble data. If you return 0 lws will echo the close and then close the connection. If you return nonzero lws will just close the connection. </td></tr>
  </table>
  </dd>
</dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad62860e19975ba4c4af401c3cdb6abf7a982579753e70e59a9ea13ce628ac891a"></a>LWS_CALLBACK_USER&#160;</td><td class="fielddoc">
<p>user code can use any including / above without fear of clashes </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae399c571df32ba532c0ca67da9284985"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985">lws_close_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_close_status - RFC6455 close status codes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a3ffa38d5081b85fb739e02a747ccf2c4"></a>LWS_CLOSE_STATUS_NORMAL&#160;</td><td class="fielddoc">
<p>1000 indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a9737a68759e739856b150ff9dfa30218"></a>LWS_CLOSE_STATUS_GOINGAWAY&#160;</td><td class="fielddoc">
<p>1001 indicates that an endpoint is "going away", such as a server going down or a browser having navigated away from a page. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a1bb501d212fa4d57053db681b1dfab98"></a>LWS_CLOSE_STATUS_PROTOCOL_ERR&#160;</td><td class="fielddoc">
<p>1002 indicates that an endpoint is terminating the connection due to a protocol error. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a462c99b05459df700919cfd3f53c8276"></a>LWS_CLOSE_STATUS_UNACCEPTABLE_OPCODE&#160;</td><td class="fielddoc">
<p>1003 indicates that an endpoint is terminating the connection because it has received a type of data it cannot accept (e.g., an endpoint that understands only text data MAY send this if it receives a binary message). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985af90cb98d983ad3d4c79df9b6f3d4a4d2"></a>LWS_CLOSE_STATUS_RESERVED&#160;</td><td class="fielddoc">
<p>Reserved. The specific meaning might be defined in the future. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a4b8a3b7ce6f731e5248e4b0fb64a5044"></a>LWS_CLOSE_STATUS_NO_STATUS&#160;</td><td class="fielddoc">
<p>1005 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that no status code was actually present. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a68b3d34bebd88547dcfa5cadba0acd6c"></a>LWS_CLOSE_STATUS_ABNORMAL_CLOSE&#160;</td><td class="fielddoc">
<p>1006 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed abnormally, e.g., without sending or receiving a Close control frame. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a7aef2da0062da606eeb35aaca5cf9050"></a>LWS_CLOSE_STATUS_INVALID_PAYLOAD&#160;</td><td class="fielddoc">
<p>1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985ad09e68295eabdddcba4e332fbea70ae5"></a>LWS_CLOSE_STATUS_POLICY_VIOLATION&#160;</td><td class="fielddoc">
<p>1008 indicates that an endpoint is terminating the connection because it has received a message that violates its policy. This is a generic status code that can be returned when there is no other more suitable status code (e.g., 1003 or 1009) or if there is a need to hide specific details about the policy. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985a2e1f0113494a58e762eed3d22e7080d8"></a>LWS_CLOSE_STATUS_MESSAGE_TOO_LARGE&#160;</td><td class="fielddoc">
<p>1009 indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985ac6a161822783ee873be1c66f48d14e0e"></a>LWS_CLOSE_STATUS_EXTENSION_REQUIRED&#160;</td><td class="fielddoc">
<p>1010 indicates that an endpoint (client) is terminating the connection because it has expected the server to negotiate one or more extension, but the server didn't return them in the response message of the WebSocket handshake. The list of extensions that are needed SHOULD appear in the /reason/ part of the Close frame. Note that this status code is not used by the server, because it can fail the WebSocket handshake instead </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985ad0869604d79e13700ae5d196a431b350"></a>LWS_CLOSE_STATUS_UNEXPECTED_CONDITION&#160;</td><td class="fielddoc">
<p>1011 indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae399c571df32ba532c0ca67da9284985ad2b477a91c8445bf34ecd43977f9b390"></a>LWS_CLOSE_STATUS_TLS_FAILURE&#160;</td><td class="fielddoc">
<p>1015 is a reserved value and MUST NOT be set as a status code in a Close control frame by an endpoint. It is designated for use in applications expecting a status code to indicate that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libwebsockets_8h.html#a41c2d763f78cc248df3b9f8645dbd2a5">lws_context_options</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_context_options - context and vhost options </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a274ed462a1a9239eb6ddf9007f5b7092"></a>LWS_SERVER_OPTION_REQUIRE_VALID_OPENSSL_CLIENT_CERT&#160;</td><td class="fielddoc">
<p>(VH) Don't allow the connection unless the client has a client cert that we recognize; provides LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a6582c985ee0ceaadc1d277030eae2d7c"></a>LWS_SERVER_OPTION_SKIP_SERVER_CANONICAL_NAME&#160;</td><td class="fielddoc">
<p>(CTX) Don't try to get the server's hostname </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a1cc4562d05cba52a6dfa0697a65ade0d"></a>LWS_SERVER_OPTION_ALLOW_NON_SSL_ON_SSL_PORT&#160;</td><td class="fielddoc">
<p>(VH) Allow non-SSL (plaintext) connections on the same port as SSL is listening... undermines the security of SSL; provides LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a273d9975675130de0c6dc937dde7c8a6"></a>LWS_SERVER_OPTION_LIBEV&#160;</td><td class="fielddoc">
<p>(CTX) Use libev event loop </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a34ab36e68c0d593b6f19b8d5ef1240a9"></a>LWS_SERVER_OPTION_DISABLE_IPV6&#160;</td><td class="fielddoc">
<p>(VH) Disable IPV6 support </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a4933347a821e73c3f1e13fb6bfc7ad93"></a>LWS_SERVER_OPTION_DISABLE_OS_CA_CERTS&#160;</td><td class="fielddoc">
<p>(VH) Don't load OS CA certs, you will need to load your own CA cert(s) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5ac56a8a6590e74a8016d0fae09fb404fc"></a>LWS_SERVER_OPTION_PEER_CERT_NOT_REQUIRED&#160;</td><td class="fielddoc">
<p>(VH) Accept connections with no valid Cert (eg, selfsigned) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5aa0158b4e85420811e6b0f1378c6ded0f"></a>LWS_SERVER_OPTION_VALIDATE_UTF8&#160;</td><td class="fielddoc">
<p>(VH) Check UT-8 correctness </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a1b2f8bde0f62adc7ebe81b2043f34c0c"></a>LWS_SERVER_OPTION_SSL_ECDH&#160;</td><td class="fielddoc">
<p>(VH) initialize ECDH ciphers </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5aff121db04a10cf8b2c5df9d4f2b89f1e"></a>LWS_SERVER_OPTION_LIBUV&#160;</td><td class="fielddoc">
<p>(CTX) Use libuv event loop </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a4832187186c4d130c68051214cd42ada"></a>LWS_SERVER_OPTION_REDIRECT_HTTP_TO_HTTPS&#160;</td><td class="fielddoc">
<p>(VH) Use http redirect to force http to https (deprecated: use mount redirection) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a7fed6a527c8d5e0acac1b4179644583a"></a>LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT&#160;</td><td class="fielddoc">
<p>(CTX) Initialize the SSL library at all </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5accc9d0d11d1124a21659586164b0962e"></a>LWS_SERVER_OPTION_EXPLICIT_VHOSTS&#160;</td><td class="fielddoc">
<p>(CTX) Only create the context when calling context create api, implies user code will create its own vhosts </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5a9637e9001d8c8b2521086bcafbd8a941"></a>LWS_SERVER_OPTION_UNIX_SOCK&#160;</td><td class="fielddoc">
<p>(VH) Use Unix socket </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5ac962efd35abf6c402f9fb14aa14f5016"></a>LWS_SERVER_OPTION_STS&#160;</td><td class="fielddoc">
<p>(VH) Send Strict Transport Security header, making clients subsequently go to https even if user asked for http </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5af62887536e25e053e68741006dba46d8"></a>LWS_SERVER_OPTION_IPV6_V6ONLY_MODIFY&#160;</td><td class="fielddoc">
<p>(VH) Enable LWS_SERVER_OPTION_IPV6_V6ONLY_VALUE to take effect </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a41c2d763f78cc248df3b9f8645dbd2a5aca5d42820b65eac5618ec3f0bd8a1160"></a>LWS_SERVER_OPTION_IPV6_V6ONLY_VALUE&#160;</td><td class="fielddoc">
<p>(VH) if set, only ipv6 allowed on the vhost </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libwebsockets_8h.html#a31eca18e50cb4357480f2fcad36ff437">lws_mount_protocols</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum lws_mount_protocols </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437a1e9f0842b0e85db50fe648ed4ba9a4b0"></a>LWSMPRO_HTTP&#160;</td><td class="fielddoc">
<p>not supported yet </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437afbd10eb4777517ed1f6bfdcf3b9ea1d1"></a>LWSMPRO_HTTPS&#160;</td><td class="fielddoc">
<p>not supported yet </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437a42f2361cfe76cd287fa8fcfc502357e2"></a>LWSMPRO_FILE&#160;</td><td class="fielddoc">
<p>serve from filesystem directory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437a13ab58b01ac6e05f595977f1e0f0db69"></a>LWSMPRO_CGI&#160;</td><td class="fielddoc">
<p>pass to CGI to handle </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437aec137a2434851bd856ceebfb697b9970"></a>LWSMPRO_REDIR_HTTP&#160;</td><td class="fielddoc">
<p>redirect to <a href="http://">http://</a> url </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437a8894d16316863077dfe530963ca59f67"></a>LWSMPRO_REDIR_HTTPS&#160;</td><td class="fielddoc">
<p>redirect to <a href="https://">https://</a> url </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a31eca18e50cb4357480f2fcad36ff437a946a88cf9c852eed2c0317f4115d19da"></a>LWSMPRO_CALLBACK&#160;</td><td class="fielddoc">
<p>hand by named protocol's callback </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193d">lws_write_protocol</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193da80e8f169fda236c56bfb795ed62903db"></a>LWS_WRITE_TEXT&#160;</td><td class="fielddoc">
<p>Send a ws TEXT message,the pointer must have LWS_PRE valid memory behind it. The receiver expects only valid utf-8 in the payload </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193daf6486c0dba50c44198100717721d9ab2"></a>LWS_WRITE_BINARY&#160;</td><td class="fielddoc">
<p>Send a ws BINARY message, the pointer must have LWS_PRE valid memory behind it. Any sequence of bytes is valid </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193da10047eb05b5e1c298151dc47a5b44826"></a>LWS_WRITE_CONTINUATION&#160;</td><td class="fielddoc">
<p>Continue a previous ws message, the pointer must have LWS_PRE valid memory behind it </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193dabb6705e1d1327cdda5025be28f07712e"></a>LWS_WRITE_HTTP&#160;</td><td class="fielddoc">
<p>Send HTTP content </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193dafe5a38e940ce56708ac814627e9c0917"></a>LWS_WRITE_HTTP_HEADERS&#160;</td><td class="fielddoc">
<p>Send http headers (http2 encodes this payload and LWS_WRITE_HTTP payload differently, http 1.x links also handle this correctly. so to be compatible with both in the future,header response part should be sent using this regardless of http version expected) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193da115440f272a5d55518adfc8099acfee3"></a>LWS_WRITE_NO_FIN&#160;</td><td class="fielddoc">
<p>This part of the message is not the end of the message </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a98b099cf8c1c7e38ad78501f270e193da220d8e8652d9b97fb66e476e2a60ffce"></a>LWS_WRITE_CLIENT_IGNORE_XOR_MASK&#160;</td><td class="fielddoc">
<p>client packet payload goes out on wire unmunged only useful for security tests <a class="el" href="protocolsince-p.html">since</a> normal servers cannot decode the content if used </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="abe71b7462afb21c767bdc67334f305af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws* lws_adopt_socket </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lws_sockfd_type&#160;</td>
          <td class="paramname"><em>accept_fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#abe71b7462afb21c767bdc67334f305af">lws_adopt_socket()</a> - adopt foreign socket as if listen socket accepted it </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>lws context </td></tr>
    <tr><td class="paramname">accept_fd</td><td>fd of already-accepted socket to adopt</td></tr>
  </table>
  </dd>
</dl>
<p>Either returns new wsi bound to accept_fd, or closes accept_fd and returns NULL, having cleaned up any new wsi pieces.</p>
<p>LWS adopts the socket in http serving mode, it's ready to accept an upgrade to ws or just serve http. </p>

</div>
</div>
<a class="anchor" id="ab2d045df0f81afe00891aaed312d552b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws* lws_adopt_socket_readbuf </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lws_sockfd_type&#160;</td>
          <td class="paramname"><em>accept_fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>readbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ab2d045df0f81afe00891aaed312d552b">lws_adopt_socket_readbuf()</a> - adopt foreign socket and first rx as if listen socket accepted it </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>lws context </td></tr>
    <tr><td class="paramname">accept_fd</td><td>fd of already-accepted socket to adopt </td></tr>
    <tr><td class="paramname">readbuf</td><td>NULL or pointer to data that must be drained before reading from accept_fd </td></tr>
    <tr><td class="paramname">len</td><td>The length of the data held at </td></tr>
  </table>
  </dd>
</dl>
<p>Either returns new wsi bound to accept_fd, or closes accept_fd and returns NULL, having cleaned up any new wsi pieces.</p>
<p>LWS adopts the socket in http serving mode, it's ready to accept an upgrade to ws or just serve http.</p>
<p>If your external code did not already read from the socket, you can use <a class="el" href="libwebsockets_8h.html#abe71b7462afb21c767bdc67334f305af">lws_adopt_socket()</a> instead.</p>
<p>This api is guaranteed to use the data at  first, before reading from the socket.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">readbuf</td><td>is limited to the size of the ah rx buf, currently 2048 bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf04bbe089f47c971c6408c5efe2ac70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_all_protocol </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#acf04bbe089f47c971c6408c5efe2ac70">lws_callback_all_protocol()</a> - Callback all connections using the given protocol with the given reason</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13c984d8c5a44a745fd02bc2fba36053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_all_protocol_vhost </td>
          <td>(</td>
          <td class="paramtype">struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a13c984d8c5a44a745fd02bc2fba36053">lws_callback_all_protocol_vhost()</a> - Callback all connections using the given protocol with the given reason</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vh</td><td>Vhost whose connections will get callbacks </td></tr>
    <tr><td class="paramname">protocol</td><td>Which protocol to match </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a941caaa468bc507b1cae52275f58800d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_on_writable </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a941caaa468bc507b1cae52275f58800d">lws_callback_on_writable()</a> - Request a callback when this socket becomes able to be written to without blocking</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance to get callback for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbe4655c7eeb3eb1671b2323ec6b3107"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_on_writable_all_protocol </td>
          <td>(</td>
          <td class="paramtype">const struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#abbe4655c7eeb3eb1671b2323ec6b3107">lws_callback_on_writable_all_protocol()</a> - Request a callback for all connections using the given protocol when it becomes possible to write to each socket without blocking in turn.</p>
<p>This calls back any connection using the same protocol on ANY VHOST.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>lws_context </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8570860e191b62db264f2bac67354ea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_on_writable_all_protocol_vhost </td>
          <td>(</td>
          <td class="paramtype">const struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vhost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a8570860e191b62db264f2bac67354ea8">lws_callback_on_writable_all_protocol_vhost()</a> - Request a callback for all connections using the given protocol when it becomes possible to write to each socket without blocking in turn.</p>
<p>This calls back connections with the same protocol ON THE SAME VHOST ONLY.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vhost</td><td>Only consider connections on this lws_vhost </td></tr>
    <tr><td class="paramname">protocol</td><td>Protocol whose connections will get callbacks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60939cf0c073d933fde3d17f3591caf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_callback_vhost_protocols </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a60939cf0c073d933fde3d17f3591caf5">lws_callback_vhost_protocols()</a> - Callback all protocols enabled on a vhost with the given reason</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>wsi whose vhost will get callbacks </td></tr>
    <tr><td class="paramname">reason</td><td>Callback reason index </td></tr>
    <tr><td class="paramname">in</td><td>in argument to callback </td></tr>
    <tr><td class="paramname">len</td><td>len argument to callback</td></tr>
  </table>
  </dd>
</dl>
<p>This is useful when informing all fellow enabled protocols on a vhost about a vhost-wide event, eg, creation or deletion of an account </p>

</div>
</div>
<a class="anchor" id="a53e3d0801dfda7960a7249dd559e68a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_cancel_service </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a53e3d0801dfda7960a7249dd559e68a2">lws_cancel_service()</a> - Cancel wait for new pending socket activity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context <pre class="fragment"> This function let a call to lws_service() waiting for a timeout
 immediately return.

 What it basically does is provide a fake event that will be swallowed,
 so the wait in poll() is ended.  That's useful because poll() doesn't
 attend to changes in POLLIN/OUT/ERR until it re-enters the wait.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29c246707997ab7a466aa709aecd2d7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_cancel_service_pt </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a29c246707997ab7a466aa709aecd2d7b">lws_cancel_service_pt()</a> - Cancel servicing of pending socket activity on one thread </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Cancel service on the thread this wsi is serviced by <pre class="fragment"> This function let a call to lws_service() waiting for a timeout
 immediately return.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0df22db2be9fc65a667a1e83f9a92a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const char* LWS_WARN_UNUSED_RESULT lws_canonical_hostname </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ad0df22db2be9fc65a667a1e83f9a92a4">lws_canonical_hostname()</a> - returns this host's hostname</p>
<p>This is typically used by client code to fill in the host parameter when making a client connection. You can only call it after the context has been created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4af0a20108a95e8b6d94dd4d80055ff3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws* LWS_WARN_UNUSED_RESULT lws_client_connect </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>clients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssl_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ietf_version_or_minus_one</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a4af0a20108a95e8b6d94dd4d80055ff3">lws_client_connect()</a> - Connect to another websocket server DEPRECATED use lws_client_connect_via_info </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">address</td><td>Remote server address, eg, "myserver.com" </td></tr>
    <tr><td class="paramname">port</td><td>Port to connect to on the remote server, eg, 80 </td></tr>
    <tr><td class="paramname">ssl_connection</td><td>0 = ws://, 1 = wss:// encrypted, 2 = wss:// allow self signed certs </td></tr>
    <tr><td class="paramname">path</td><td>Websocket path on server </td></tr>
    <tr><td class="paramname">host</td><td>Hostname on server </td></tr>
    <tr><td class="paramname">origin</td><td>Socket origin name </td></tr>
    <tr><td class="paramname">protocol</td><td>Comma-separated list of protocols being asked for from the server, or just one. The server will pick the one it likes best. If you don't want to specify a protocol, which is legal, use NULL here. </td></tr>
    <tr><td class="paramname">ietf_version_or_minus_one</td><td>-1 to ask to connect using the default, latest protocol supported, or the specific protocol ordinal</td></tr>
  </table>
  </dd>
</dl>
<p>This function creates a connection to a remote server </p>

</div>
</div>
<a class="anchor" id="ac6a8558b4410961a880241c2ac1271e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws* LWS_WARN_UNUSED_RESULT lws_client_connect_extended </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>clients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ssl_connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ietf_version_or_minus_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ac6a8558b4410961a880241c2ac1271e2">lws_client_connect_extended()</a> - Connect to another websocket server DEPRECATED use lws_client_connect_via_info </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">address</td><td>Remote server address, eg, "myserver.com" </td></tr>
    <tr><td class="paramname">port</td><td>Port to connect to on the remote server, eg, 80 </td></tr>
    <tr><td class="paramname">ssl_connection</td><td>0 = ws://, 1 = wss:// encrypted, 2 = wss:// allow self signed certs </td></tr>
    <tr><td class="paramname">path</td><td>Websocket path on server </td></tr>
    <tr><td class="paramname">host</td><td>Hostname on server </td></tr>
    <tr><td class="paramname">origin</td><td>Socket origin name </td></tr>
    <tr><td class="paramname">protocol</td><td>Comma-separated list of protocols being asked for from the server, or just one. The server will pick the one it likes best. </td></tr>
    <tr><td class="paramname">ietf_version_or_minus_one</td><td>-1 to ask to connect using the default, latest protocol supported, or the specific protocol ordinal </td></tr>
    <tr><td class="paramname">userdata</td><td>Pre-allocated user data <pre class="fragment"> This function creates a connection to a remote server</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac30a7be106abd0cedfbb2e8b8fe3a2f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws* LWS_WARN_UNUSED_RESULT lws_client_connect_via_info </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structlws__client__connect__info.html">lws_client_connect_info</a> *&#160;</td>
          <td class="paramname"><em>ccinfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ac30a7be106abd0cedfbb2e8b8fe3a2f5">lws_client_connect_via_info()</a> - Connect to another websocket server </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i:pointer</td><td>to <a class="el" href="structlws__client__connect__info.html">lws_client_connect_info</a> struct <pre class="fragment"> This function creates a connection to a remote server</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1c863415d1783cd8de7938aa6efa262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_close_reason </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="libwebsockets_8h.html#ae399c571df32ba532c0ca67da9284985">lws_close_status</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_close_reason - Set reason and aux data to send with Close packet If you are going to return nonzero from the callback requesting the connection to close, you can optionally call this to set the reason the peer will be told if possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>The websocket connection to set the close reason on </td></tr>
    <tr><td class="paramname">status</td><td>A valid close status from websocket standard </td></tr>
    <tr><td class="paramname">buf</td><td>NULL or buffer containing up to 124 bytes of auxiliary data </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in  to send </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ee0314028755f1ddfa9428e09b4fddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_context_destroy </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a8ee0314028755f1ddfa9428e09b4fddb">lws_context_destroy()</a> - Destroy the websocket context </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context <pre class="fragment"> This function closes any active connections and then frees the
 context.  After calling this, any further use of the context is
 undefined.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb12f934bfd178bd2132a9e73fc641da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void* lws_context_user </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#aeb12f934bfd178bd2132a9e73fc641da">lws_context_user()</a> - get the user data associated with the context </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context <pre class="fragment"> This returns the optional user allocation that can be attached to
 the context the sockets live in at context_create time.  It's a way
 to let all sockets serviced in the same context share data without
 using globals statics in the user code.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="accd9c59336efad8af0554f79cc5966fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_frame_is_binary </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_frame_is_binary: true if the current frame was sent in binary mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>the connection we are inquiring about</td></tr>
  </table>
  </dd>
</dl>
<p>This is intended to be called from the LWS_CALLBACK_RECEIVE callback if it's interested to see if the frame it's dealing with was sent in binary mode. </p>

</div>
</div>
<a class="anchor" id="a0af4f7d2dd375aeedcfa7eb0e1101c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws_context* LWS_WARN_UNUSED_RESULT lws_get_context </td>
          <td>(</td>
          <td class="paramtype">const struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_get_context - Allow geting lws_context from a Websocket connection instance</p>
<p>With this function, users can access context in the callback function. Otherwise users may have to declare context as a global variable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72ad550786ca7976463589d347e62112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const struct <a class="el" href="structlws__protocols.html">lws_protocols</a>* lws_get_protocol </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a72ad550786ca7976463589d347e62112">lws_get_protocol()</a> - Returns a protocol pointer from a websocket connection. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>pointer to struct websocket you want to know the protocol of</td></tr>
  </table>
  </dd>
</dl>
<pre class="fragment"> Some apis can act on all live connections of a given protocol,
 this is how you can get a pointer to the active protocol if needed.</pre> 
</div>
</div>
<a class="anchor" id="aa709e02a10558753c851e58f1e2c16ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_get_socket_fd </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#aa709e02a10558753c851e58f1e2c16ba">lws_get_socket_fd()</a> - returns the socket file descriptor</p>
<p>You will not need this unless you are doing something special</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84e9ce5e71a77501a0998ac403a984c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const char* lws_get_urlarg_by_name </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a84e9ce5e71a77501a0998ac403a984c2">lws_get_urlarg_by_name()</a> - return pointer to arg value if present </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>the connection to check </td></tr>
    <tr><td class="paramname">name</td><td>the arg name, like "token=" </td></tr>
    <tr><td class="paramname">buf</td><td>the buffer to receive the urlarg (including the name= part) </td></tr>
    <tr><td class="paramname">len</td><td>the length of the buffer to receive the urlarg <pre class="fragment">Returns NULL if not found or a pointer inside @buf to just after the
name= part.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ce6aa1c0155ea42b7708bed271d1c77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_hdr_copy </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lws_token_indexes&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_hdr_copy: copy a single fragment of the given header to a buffer The buffer length  must include space for an additional terminating '\0', or it will fail returning -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection </td></tr>
    <tr><td class="paramname">dst</td><td>destination buffer </td></tr>
    <tr><td class="paramname">len</td><td>length of destination buffer </td></tr>
    <tr><td class="paramname">h</td><td>which header index we are interested in</td></tr>
  </table>
  </dd>
</dl>
<p>copies the whole, aggregated header, even if it was delivered in several actual headers piece by piece </p>

</div>
</div>
<a class="anchor" id="aa427cad61a9a5e3004afd65c4527b5e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_hdr_copy_fragment </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lws_token_indexes&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frag_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_hdr_copy_fragment: copy a single fragment of the given header to a buffer The buffer length  must include space for an additional terminating '\0', or it will fail returning -1. If the requested fragment index is not present, it fails returning -1.</p>
<p>Normally this is only useful to parse URI arguments like ?x=1&amp;y=2, token index WSI_TOKEN_HTTP_URI_ARGS fragment 0 will contain "x=1" and fragment 1 "y=2"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection </td></tr>
    <tr><td class="paramname">dst</td><td>destination buffer </td></tr>
    <tr><td class="paramname">len</td><td>length of destination buffer </td></tr>
    <tr><td class="paramname">h</td><td>which header index we are interested in </td></tr>
    <tr><td class="paramname">frag_index</td><td>which fragment of  we want to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a594f3d0ece5b09c2ccf9f98ea533bb4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_hdr_fragment_length </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lws_token_indexes&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frag_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_hdr_fragment_length: report length of a single fragment of a header The returned length does not include the space for a terminating '\0'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection </td></tr>
    <tr><td class="paramname">h</td><td>which header index we are interested in </td></tr>
    <tr><td class="paramname">frag_idx</td><td>which fragment of  we want to get the length of </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ade0e1ffb0da7e62b989d8d867bf6c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_hdr_total_length </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum lws_token_indexes&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_hdr_total_length: report length of all fragments of a header totalled up The returned length does not include the space for a terminating '\0'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection </td></tr>
    <tr><td class="paramname">h</td><td>which header index we are interested in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad27aed6c66a41b2b89ffe4da2a309e8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_http_transaction_completed </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ad27aed6c66a41b2b89ffe4da2a309e8a">lws_http_transaction_completed()</a> - wait for new http transaction or close </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection <pre class="fragment"> Returns 1 if the HTTP connection must close now
 Returns 0 and resets connection to wait for new HTTP header /
   transaction if possible</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f44b8230e6732816ca5cd8d1aaaf340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_init_vhost_client_ssl </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structlws__context__creation__info.html">lws_context_creation_info</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vhost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a4f44b8230e6732816ca5cd8d1aaaf340">lws_init_vhost_client_ssl()</a> - also enable client SSL on an existing vhost</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>client ssl related info </td></tr>
    <tr><td class="paramname">vhost</td><td>which vhost to initialize client ssl operations on</td></tr>
  </table>
  </dd>
</dl>
<p>You only need to call this if you plan on using SSL client connections on the vhost. For non-SSL client connections, it's not necessary to call this.</p>
<p>The following members of  are used during the call </p><pre class="fragment">  - @options must have LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT set,
      otherwise the call does nothing
  - @provided_client_ssl_ctx must be NULL to get a generated client
      ssl context, otherwise you can pass a prepared one in by setting it
  - @ssl_cipher_list may be NULL or set to the client valid cipher list
  - @ssl_ca_filepath may be NULL or client cert filepath
  - @ssl_cert_filepath may be NULL or client cert filepath
  - @ssl_private_key_filepath may be NULL or client cert private key
</pre><p>You must create your vhost explicitly if you want to use this, so you have a pointer to the vhost. Create the context first with the option flag LWS_SERVER_OPTION_EXPLICIT_VHOSTS and then call lws_create_vhost() with the same info struct. </p>

</div>
</div>
<a class="anchor" id="a26a140623d202dd2bf2004deb6994baa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_is_ssl </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a26a140623d202dd2bf2004deb6994baa">lws_is_ssl()</a> - Find out if connection is using SSL </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection to check <pre class="fragment"> Returns 0 if the connection is not using SSL, 1 if using SSL and
 using verified cert, and 2 if using SSL but the cert was not
 checked (appears for client wsi told to skip check on connection)</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab15187efcfa256b7c928562c182b92a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const char* lws_json_purify </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>escaped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ab15187efcfa256b7c928562c182b92a3">lws_json_purify()</a> - like strncpy but with escaping for json chars</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>output buffer </td></tr>
    <tr><td class="paramname">string</td><td>input buffer ('/0' terminated) </td></tr>
    <tr><td class="paramname">len</td><td>output buffer max length</td></tr>
  </table>
  </dd>
</dl>
<p>Because escaping expands the output string, it's not possible to do it in-place, ie, with escaped == string </p>

</div>
</div>
<a class="anchor" id="a1ec0d9faac5d3a5824d765c287c043aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_parse_uri </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>ads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lws_parse_uri: cut up prot:/ads:port/path into pieces Notice it does so by dropping '\0' into input string and the leading / on the path is consequently lost</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>incoming uri string.. will get written to </td></tr>
    <tr><td class="paramname">prot</td><td>result pointer for protocol part (<a href="https://">https://</a>) </td></tr>
    <tr><td class="paramname">ads</td><td>result pointer for address part </td></tr>
    <tr><td class="paramname">port</td><td>result pointer for port part </td></tr>
    <tr><td class="paramname">path</td><td>result pointer for path part </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeca4afc94b1f026034f99cbba37e2f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int LWS_WARN_UNUSED_RESULT lws_partial_buffered </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#aeca4afc94b1f026034f99cbba37e2f85">lws_partial_buffered()</a> - find out if lws buffered the last write </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection to check</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 1 if you cannot use lws_write because the last write on this connection is still buffered, and can't be cleared without returning to the service loop and waiting for the connection to be writeable again.</p>
<p>If you will try to do &gt;1 lws_write call inside a single WRITEABLE callback, you must check this after every write and bail if set, ask for a new writeable callback and continue writing from there.</p>
<p>This is never set at the start of a writeable callback, but any write may set it. </p>

</div>
</div>
<a class="anchor" id="a72fe65e83b8bb03f904a1a256c673536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN size_t lws_remaining_packet_payload </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a72fe65e83b8bb03f904a1a256c673536">lws_remaining_packet_payload()</a> - Bytes to come before "overall" rx packet is complete </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket instance (available from user callback) <pre class="fragment"> This function is intended to be called from the callback if the
</pre> user code is interested in "complete packets" from the client. libwebsockets just passes through payload as it comes and issues a buffer additionally when it hits a built-in limit. The LWS_CALLBACK_RECEIVE callback handler can use this API to find out if the buffer it has just been given is the last piece of a "complete packet" from the client &ndash; when that is the case <a class="el" href="libwebsockets_8h.html#a72fe65e83b8bb03f904a1a256c673536">lws_remaining_packet_payload()</a> will return 0.</td></tr>
  </table>
  </dd>
</dl>
<p>Many protocols won't care becuse their packets are always small. </p>

</div>
</div>
<a class="anchor" id="ac8a4a71240857dc6b2ed70456b6923f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_return_http_status </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>html_body</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ac8a4a71240857dc6b2ed70456b6923f4">lws_return_http_status()</a> - Return simple http status </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket instance (available from user callback) </td></tr>
    <tr><td class="paramname">code</td><td>Status index, eg, 404 </td></tr>
    <tr><td class="paramname">html_body</td><td>User-readable HTML description &lt; 1KB, or NULL <pre class="fragment"> Helper to report HTTP errors back to the client cleanly and
 consistently</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e627dbf1db48170ef486edbaf268672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_rx_flow_allow_all_protocol </td>
          <td>(</td>
          <td class="paramtype">const struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structlws__protocols.html">lws_protocols</a> *&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a5e627dbf1db48170ef486edbaf268672">lws_rx_flow_allow_all_protocol()</a> - Allow all connections with this protocol to receive</p>
<p>When the user server code realizes it can accept more input, it can call this to have the RX flow restriction removed from all connections using the given protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>all connections using this protocol will be allowed to receive </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf4abd01e8c43f07c6e498ce13590c3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_rx_flow_control </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#adf4abd01e8c43f07c6e498ce13590c3e">lws_rx_flow_control()</a> - Enable and disable socket servicing for received packets.</p>
<p>If the output side of a server process becomes choked, this allows flow control for the input side.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance to get callback for </td></tr>
    <tr><td class="paramname">enable</td><td>0 = disable read servicing for this connection, 1 = enable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab393a06d3d2722af4c3f8b06842c80d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_serve_http_file </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>content_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>other_headers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>other_headers_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ab393a06d3d2722af4c3f8b06842c80d7">lws_serve_http_file()</a> - Send a file back to the client using http </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket instance (available from user callback) </td></tr>
    <tr><td class="paramname">file</td><td>The file to issue over http </td></tr>
    <tr><td class="paramname">content_type</td><td>The http content type, eg, text/html </td></tr>
    <tr><td class="paramname">other_headers</td><td>NULL or pointer to header string </td></tr>
    <tr><td class="paramname">other_headers_len</td><td>length of the other headers if non-NULL <pre class="fragment"> This function is intended to be called from the callback in response
 to http requests from the client.  It allows the callback to issue
 local files down the http link in a single step.

 Returning &lt;0 indicates error and the wsi should be closed.  Returning
 &gt;0 indicates the file was completely sent and
 lws_http_transaction_completed() called on the wsi (and close if != 0)
 ==0 indicates the file transfer is started and needs more service later,
 the wsi should be left alone.</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af95bd0c663d6516a0c80047d9b1167a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_service </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#af95bd0c663d6516a0c80047d9b1167a8">lws_service()</a> - Service any pending websocket activity </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>Timeout for poll; 0 means return immediately if nothing needed service otherwise block and service immediately, returning after the timeout if nothing needed service.</td></tr>
  </table>
  </dd>
</dl>
<p>This function deals with any pending websocket traffic, for three kinds of event. It handles these events on both server and client types of connection the same.</p>
<p>1) Accept new connections to our context's server</p>
<p>2) Call the receive callback for incoming frame data received by server or client connections.</p>
<p>You need to call this service function periodically to all the above functions to happen; if your application is single-threaded you can just call it in your main event loop.</p>
<p>Alternatively you can fork a new process that asynchronously handles calling this service in a loop. In that case you are happy if this call blocks your thread until it needs to take care of something and would call it with a large nonzero timeout. Your loop then takes no CPU while there is nothing happening.</p>
<p>If you are calling it in a single-threaded app, you don't want it to wait around blocking other things in your loop from happening, so you would call it with a timeout_ms of 0, so it returns immediately if nothing is pending, or as soon as it services whatever was pending. </p>

</div>
</div>
<a class="anchor" id="ad82efa5466d14a9f05aa06416375b28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_service_fd </td>
          <td>(</td>
          <td class="paramtype">struct lws_context *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct lws_pollfd *&#160;</td>
          <td class="paramname"><em>pollfd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ad82efa5466d14a9f05aa06416375b28d">lws_service_fd()</a> - Service polled socket with something waiting </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Websocket context </td></tr>
    <tr><td class="paramname">pollfd</td><td>The pollfd entry describing the socket fd and which events happened.</td></tr>
  </table>
  </dd>
</dl>
<p>This function takes a pollfd that has POLLIN or POLLOUT activity and services it according to the state of the associated struct lws.</p>
<p>The one call deals with all "service" that might happen on a socket including listen accepts, http files as well as websocket protocol.</p>
<p>If a pollfd says it has something, you can just pass it to <a class="el" href="libwebsockets_8h.html#ad82efa5466d14a9f05aa06416375b28d">lws_service_fd()</a> whether it is a socket handled by lws or not. If it sees it is a lws socket, the traffic will be handled and pollfd-&gt;revents will be zeroed now.</p>
<p>If the socket is foreign to lws, it leaves revents alone. So you can see if you should service yourself by checking the pollfd revents after letting lws try to service it. </p>

</div>
</div>
<a class="anchor" id="ae0e24e1768f83a7fb07896ce975704b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_set_extension_option </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ext_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>opt_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ae0e24e1768f83a7fb07896ce975704b9">lws_set_extension_option()</a>: set extension option if possible</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>websocket connection </td></tr>
    <tr><td class="paramname">ext_name</td><td>name of ext, like "permessage-deflate" </td></tr>
    <tr><td class="paramname">opt_name</td><td>name of option, like "rx_buf_size" </td></tr>
    <tr><td class="paramname">opt_val</td><td>value to set option to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a244647f9e1bf0097ccdde66d74f41e26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_set_log_level </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int level, const char *line)&#160;</td>
          <td class="paramname"><em>log_emit_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a244647f9e1bf0097ccdde66d74f41e26">lws_set_log_level()</a> - Set the logging bitfield </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>OR together the LLL_ debug contexts you want output from </td></tr>
    <tr><td class="paramname">log_emit_function</td><td>NULL to leave it as it is, or a user-supplied function to perform log string emission instead of the default stderr one.</td></tr>
  </table>
  </dd>
</dl>
<p>log level defaults to "err", "warn" and "notice" contexts enabled and emission on stderr. </p>

</div>
</div>
<a class="anchor" id="a7e9d5405547a457d86e0b4f0ae2bb1c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_set_proxy </td>
          <td>(</td>
          <td class="paramtype">struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vhost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>proxy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a7e9d5405547a457d86e0b4f0ae2bb1c4">lws_set_proxy()</a> - Setups proxy to lws_context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>pointer to struct lws_context you want set proxy to </td></tr>
    <tr><td class="paramname">proxy</td><td>pointer to c string containing proxy in format address:port</td></tr>
  </table>
  </dd>
</dl>
<p>Returns 0 if proxy string was parsed and proxy was setup. Returns -1 if  is NULL or has incorrect format.</p>
<p>This is only required if your OS does not provide the http_proxy environment variable (eg, OSX)</p>
<p>IMPORTANT! You should call this function right after creation of the lws_context and before call to connect. If you call this function after connect behavior is undefined. This function will override proxy settings made on lws_context creation with genenv() call. </p>

</div>
</div>
<a class="anchor" id="aced9f9237f6172fed9f730a2af51345a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN void lws_set_timeout </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum pending_timeout&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>secs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#aced9f9237f6172fed9f730a2af51345a">lws_set_timeout()</a> - marks the wsi as subject to a timeout</p>
<p>You will not need this unless you are doing something special</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket connection instance </td></tr>
    <tr><td class="paramname">reason</td><td>timeout reason </td></tr>
    <tr><td class="paramname">secs</td><td>how many seconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a162f86762173a2bc8c28497941d74815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN struct lws_spa* lws_spa_create </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>param_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lws_spa_fileupload_cb&#160;</td>
          <td class="paramname"><em>opt_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>opt_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a162f86762173a2bc8c28497941d74815">lws_spa_create()</a> - create urldecode parser</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>lws connection (used to find Content Type) </td></tr>
    <tr><td class="paramname">param_names</td><td>array of form parameter names, like "username" </td></tr>
    <tr><td class="paramname">count_params</td><td>count of param_names </td></tr>
    <tr><td class="paramname">max_storage</td><td>total amount of form parameter values we can store </td></tr>
    <tr><td class="paramname">opt_cb</td><td>NULL, or callback to receive file upload data. </td></tr>
    <tr><td class="paramname">opt_data</td><td>NULL, or user pointer provided to opt_cb.</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a urldecode parser and initializes it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt_cb</td><td>can be NULL if you just want normal name=value parsing, however if one or more entries in your form are bulk data (file transfer), you can provide this callback and filter on the name callback parameter to treat that urldecoded data separately. The callback should return -1 in case of fatal error, and 0 if OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26e2a32318f00c7797943681c91fceed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_spa_destroy </td>
          <td>(</td>
          <td class="paramtype">struct lws_spa *&#160;</td>
          <td class="paramname"><em>ludspa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a26e2a32318f00c7797943681c91fceed">lws_spa_destroy()</a> - destroy parser object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ludspa</td><td>the parser object previously created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb45918f9a0417540152c395f37150a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_spa_finalize </td>
          <td>(</td>
          <td class="paramtype">struct lws_spa *&#160;</td>
          <td class="paramname"><em>ludspa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#adb45918f9a0417540152c395f37150a7">lws_spa_finalize()</a> - indicate incoming data completed</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ludspa</td><td>the parser object previously created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae207309c4e5ea7a1485ca8bdc663cce0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_spa_get_length </td>
          <td>(</td>
          <td class="paramtype">struct lws_spa *&#160;</td>
          <td class="paramname"><em>ludspa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ae207309c4e5ea7a1485ca8bdc663cce0">lws_spa_get_length()</a> - return length of parameter value</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ludspa</td><td>the parser object previously created </td></tr>
    <tr><td class="paramname">n</td><td>parameter ordinal to return length of value for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab65e00386b9188a53b4bdb62522a1f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const char* lws_spa_get_string </td>
          <td>(</td>
          <td class="paramtype">struct lws_spa *&#160;</td>
          <td class="paramname"><em>ludspa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ab65e00386b9188a53b4bdb62522a1f09">lws_spa_get_string()</a> - return pointer to parameter value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ludspa</td><td>the parser object previously created </td></tr>
    <tr><td class="paramname">n</td><td>parameter ordinal to return pointer to value for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad217392f627774fd4f34c6e92b493d2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_spa_process </td>
          <td>(</td>
          <td class="paramtype">struct lws_spa *&#160;</td>
          <td class="paramname"><em>ludspa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#ad217392f627774fd4f34c6e92b493d2a">lws_spa_process()</a> - parses a chunk of input data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ludspa</td><td>the parser object previously created </td></tr>
    <tr><td class="paramname">in</td><td>incoming, urlencoded data </td></tr>
    <tr><td class="paramname">len</td><td>count of bytes valid at  </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cc82f06e5ae7e71458626d7a39a5865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const char* lws_sql_purify </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>escaped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a9cc82f06e5ae7e71458626d7a39a5865">lws_sql_purify()</a> - like strncpy but with escaping for sql quotes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>output buffer </td></tr>
    <tr><td class="paramname">string</td><td>input buffer ('/0' terminated) </td></tr>
    <tr><td class="paramname">len</td><td>output buffer max length</td></tr>
  </table>
  </dd>
</dl>
<p>Because escaping expands the output string, it's not possible to do it in-place, ie, with escaped == string </p>

</div>
</div>
<a class="anchor" id="aa373a9c16acdd96c395af61ab915ece3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_urldecode </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>escaped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#aa373a9c16acdd96c395af61ab915ece3">lws_urldecode()</a> - like strncpy but with urldecoding</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>output buffer </td></tr>
    <tr><td class="paramname">escaped</td><td>input buffer ('\0' terminated) </td></tr>
    <tr><td class="paramname">len</td><td>output buffer max length</td></tr>
  </table>
  </dd>
</dl>
<p>This is only useful for '\0' terminated strings</p>
<p>Since urldecoding only shrinks the output string, it is possible to do it in-place, ie, string == escaped </p>

</div>
</div>
<a class="anchor" id="abc2888476e50e001c875c1a8abf455b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const char* lws_urlencode </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>escaped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#abc2888476e50e001c875c1a8abf455b7">lws_urlencode()</a> - like strncpy but with urlencoding</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">escaped</td><td>output buffer </td></tr>
    <tr><td class="paramname">string</td><td>input buffer ('/0' terminated) </td></tr>
    <tr><td class="paramname">len</td><td>output buffer max length</td></tr>
  </table>
  </dd>
</dl>
<p>Because urlencoding expands the output string, it's not possible to do it in-place, ie, with escaped == string </p>

</div>
</div>
<a class="anchor" id="a25754726d97c5f519d313e691a9fe29d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN const struct <a class="el" href="structlws__protocols.html">lws_protocols</a>* lws_vhost_name_to_protocol </td>
          <td>(</td>
          <td class="paramtype">struct lws_vhost *&#160;</td>
          <td class="paramname"><em>vh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#a25754726d97c5f519d313e691a9fe29d">lws_vhost_name_to_protocol()</a> - get vhost's protocol object from its name</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vh</td><td>vhost to search </td></tr>
    <tr><td class="paramname">name</td><td>protocol name</td></tr>
  </table>
  </dd>
</dl>
<p>Returns NULL or a pointer to the vhost's protocol of the requested name </p>

</div>
</div>
<a class="anchor" id="afd5fdd285a0e25ba7e3e1051deec1001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lws_write </td>
          <td>(</td>
          <td class="paramtype">struct lws *&#160;</td>
          <td class="paramname"><em>wsi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="libwebsockets_8h.html#a98b099cf8c1c7e38ad78501f270e193d">lws_write_protocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="libwebsockets_8h.html#afd5fdd285a0e25ba7e3e1051deec1001">lws_write()</a> - Apply protocol then write data to client </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wsi</td><td>Websocket instance (available from user callback) </td></tr>
    <tr><td class="paramname">buf</td><td>The data to send. For data being sent on a websocket connection (ie, not default http), this buffer MUST have LWS_PRE bytes valid BEFORE the pointer. This is so the protocol header data can be added in-situ. </td></tr>
    <tr><td class="paramname">len</td><td>Count of the data bytes in the payload starting from buf </td></tr>
    <tr><td class="paramname">protocol</td><td>Use LWS_WRITE_HTTP to reply to an http connection, and one of LWS_WRITE_BINARY or LWS_WRITE_TEXT to send appropriate data on a websockets connection. Remember to allow the extra bytes before and after buf if LWS_WRITE_BINARY or LWS_WRITE_TEXT are used.</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides the way to issue data back to the client for both http and websocket protocols.</p>
<p>In the case of sending using websocket protocol, be sure to allocate valid storage before and after buf as explained above. This scheme allows maximum efficiency of sending data and protocol in a single packet while not burdening the user code with any protocol knowledge.</p>
<p>Return may be -1 for a fatal error needing connection close, or a positive number reflecting the amount of bytes actually sent. This can be less than the requested number of bytes due to OS memory pressure at any given time. </p>

</div>
</div>
<a class="anchor" id="a42e39775c6b69b7251bdbf5a2cdd5dcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LWS_VISIBLE LWS_EXTERN int lwsl_timestamp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>lwsl_timestamp: generate logging timestamp string</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>logging level </td></tr>
    <tr><td class="paramname">p</td><td>char * buffer to take timestamp </td></tr>
    <tr><td class="paramname">len</td><td>length of p</td></tr>
  </table>
  </dd>
</dl>
<p>returns length written in p </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
